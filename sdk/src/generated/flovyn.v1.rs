// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollRequest {
    /// Unique identifier for this worker
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    /// Tenant ID to poll workflows from
    #[prost(string, tag = "2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Task queue to poll from (e.g., "default", "gpu-workers")
    #[prost(string, tag = "3")]
    pub task_queue: ::prost::alloc::string::String,
    /// Long polling timeout in seconds (e.g., 60)
    #[prost(int64, tag = "4")]
    pub timeout_seconds: i64,
    /// Worker pool ID to poll from (NULL = default shared pool)
    #[prost(string, optional, tag = "5")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionRequest {
    /// Unique identifier for this worker
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    /// Tenant ID to subscribe to
    #[prost(string, tag = "2")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Task queue to subscribe to
    #[prost(string, tag = "3")]
    pub task_queue: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollResponse {
    /// Workflow to execute (null if no work available)
    #[prost(message, optional, tag = "1")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecution {
    /// Unique workflow execution ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Workflow kind/type
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// Tenant ID
    #[prost(string, tag = "3")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Input data (serialized bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Task queue for worker routing (e.g., "default", "gpu-workers")
    #[prost(string, tag = "5")]
    pub task_queue: ::prost::alloc::string::String,
    /// Time-offset priority in milliseconds (priority score = created_at - priority_ms)
    #[prost(int64, tag = "6")]
    pub priority_ms: i64,
    /// Creation timestamp (milliseconds since epoch)
    #[prost(int64, tag = "7")]
    pub created_at_ms: i64,
    /// Current sequence number for event sourcing
    #[prost(int32, tag = "8")]
    pub current_sequence: i32,
    /// Visual workflow definition ID (if this is a visual workflow)
    #[prost(string, optional, tag = "9")]
    pub workflow_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Space ID (if workflow is scoped to a space)
    #[prost(string, optional, tag = "10")]
    pub space_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Worker pool ID (denormalized for dispatch efficiency)
    #[prost(string, optional, tag = "11")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Locked workflow version (Phase 9: Version Locking)
    /// For code-first: semantic version (e.g., "1.0.0")
    /// For visual: version number as string (e.g., "1", "2")
    #[prost(string, optional, tag = "12")]
    pub workflow_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Workflow definition snapshot (Phase 9: Version Locking)
    /// Cached JSON definition for version isolation (visual workflows only)
    #[prost(string, optional, tag = "13")]
    pub workflow_definition_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    /// Time when this workflow task was created (milliseconds since epoch)
    /// Used for deterministic ctx.currentTimeMillis()
    /// This value is consistent across replays for the same workflow task
    #[prost(int64, tag = "14")]
    pub workflow_task_time_millis: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAvailableEvent {
    /// Tenant ID where work is available
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    /// Task queue where work is available
    #[prost(string, tag = "2")]
    pub task_queue: ::prost::alloc::string::String,
    /// Timestamp of notification (milliseconds since epoch)
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowRequest {
    #[prost(string, tag = "1")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_kind: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, string", tag = "4")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Task queue routing (default: "default")
    #[prost(string, tag = "5")]
    pub task_queue: ::prost::alloc::string::String,
    /// Time-offset priority in seconds (default: 0)
    #[prost(int32, tag = "6")]
    pub priority_seconds: i32,
    #[prost(string, optional, tag = "7")]
    pub workflow_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub parent_workflow_execution_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Workflow version selection (Phase 9: Version Locking)
    /// For code-first: semantic version (e.g., "1.0.0"), empty = latest/default
    /// For visual: version number as string (e.g., "1", "2"), empty = latest
    #[prost(string, optional, tag = "9")]
    pub workflow_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Idempotency key for preventing duplicate executions
    /// If provided, subsequent requests with the same key return the existing execution
    #[prost(string, optional, tag = "10")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Time-to-live for the idempotency key in seconds
    /// Default: 86400 (1 day), Maximum: 2592000 (30 days)
    #[prost(int64, optional, tag = "11")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowResponse {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    /// Whether an idempotency key was used for this request
    #[prost(bool, tag = "2")]
    pub idempotency_key_used: bool,
    /// Whether a new execution was created (false means existing execution was returned)
    #[prost(bool, tag = "3")]
    pub idempotency_key_new: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVisualWorkflowDefinitionByIdRequest {
    #[prost(string, tag = "1")]
    pub workflow_definition_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVisualWorkflowDefinitionByIdResponse {
    #[prost(string, tag = "1")]
    pub workflow_definition_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub definition: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub version: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowRequest {
    #[prost(string, tag = "1")]
    pub parent_workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub child_execution_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Task queue (inherits parent if empty)
    #[prost(string, tag = "7")]
    pub task_queue: ::prost::alloc::string::String,
    /// Time-offset priority in seconds (default: 0)
    #[prost(int32, tag = "8")]
    pub priority_seconds: i32,
    #[prost(
        oneof = "start_child_workflow_request::WorkflowExecutionIdentifier",
        tags = "4, 5"
    )]
    pub workflow_execution_identifier:
        ::core::option::Option<start_child_workflow_request::WorkflowExecutionIdentifier>,
}
/// Nested message and enum types in `StartChildWorkflowRequest`.
pub mod start_child_workflow_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WorkflowExecutionIdentifier {
        #[prost(string, tag = "4")]
        WorkflowKind(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        WorkflowDefinitionId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowResponse {
    #[prost(string, tag = "1")]
    pub child_workflow_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvePromiseRequest {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectPromiseRequest {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsRequest {
    /// Workflow execution ID
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<WorkflowEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowEvent {
    /// Sequence number
    #[prost(int32, tag = "1")]
    pub sequence_number: i32,
    /// Event type (e.g., "TASK_SCHEDULED", "TASK_COMPLETED")
    #[prost(string, tag = "2")]
    pub event_type: ::prost::alloc::string::String,
    /// Event data (JSON structure)
    #[prost(bytes = "vec", tag = "3")]
    pub event_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowRequest {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub params: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTaskRequest {
    /// Optional for standalone tasks (empty string = standalone)
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub task_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    #[prost(map = "string, string", tag = "5")]
    pub labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(int32, tag = "6")]
    pub max_retries: i32,
    #[prost(int64, tag = "7")]
    pub timeout_ms: i64,
    /// Idempotency key to prevent duplicate task executions
    #[prost(string, optional, tag = "8")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// TTL for the idempotency key in seconds (default: 1 day, max: 30 days)
    #[prost(int64, optional, tag = "9")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
    /// Queue for task routing (default: "default")
    #[prost(string, tag = "10")]
    pub queue: ::prost::alloc::string::String,
    /// Worker pool ID for tenant isolation (empty = any pool)
    #[prost(string, optional, tag = "11")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTaskResponse {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    /// Whether an idempotency key was used for this request
    #[prost(bool, tag = "2")]
    pub idempotency_key_used: bool,
    /// Whether a new task execution was created (false if existing execution was returned)
    #[prost(bool, tag = "3")]
    pub idempotency_key_new: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollTaskRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub tenant_id: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub worker_labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub timeout_seconds: i64,
    /// Queue to poll tasks from (default: "default")
    #[prost(string, tag = "5")]
    pub queue: ::prost::alloc::string::String,
    /// Worker pool ID for tenant isolation (empty = any pool)
    #[prost(string, optional, tag = "6")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollTaskResponse {
    #[prost(message, optional, tag = "1")]
    pub task: ::core::option::Option<TaskExecutionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskExecutionInfo {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub task_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Empty string for standalone tasks
    #[prost(string, tag = "4")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub execution_count: i32,
    /// Queue this task belongs to
    #[prost(string, tag = "6")]
    pub queue: ::prost::alloc::string::String,
    /// Worker pool ID (empty = shared pool)
    #[prost(string, optional, tag = "7")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteTaskRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub output: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailTaskRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportProgressRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub progress: f64,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTaskRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogMessageRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub level: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateResponse {
    /// Value as JSON (null if not found)
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearAllStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateKeysRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateKeysResponse {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamTaskDataRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub sequence: i32,
    #[prost(enumeration = "StreamEventType", tag = "4")]
    pub r#type: i32,
    #[prost(string, tag = "5")]
    pub payload: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub timestamp_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamTaskDataResponse {
    #[prost(bool, tag = "1")]
    pub acknowledged: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowCommand {
    #[prost(enumeration = "CommandType", tag = "1")]
    pub command_type: i32,
    #[prost(int32, tag = "2")]
    pub sequence_number: i32,
    #[prost(
        oneof = "workflow_command::CommandData",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22"
    )]
    pub command_data: ::core::option::Option<workflow_command::CommandData>,
}
/// Nested message and enum types in `WorkflowCommand`.
pub mod workflow_command {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CommandData {
        #[prost(message, tag = "10")]
        RecordOperation(super::RecordOperationCommand),
        #[prost(message, tag = "11")]
        SetState(super::SetStateCommand),
        #[prost(message, tag = "12")]
        ClearState(super::ClearStateCommand),
        #[prost(message, tag = "13")]
        ScheduleTask(super::ScheduleTaskCommand),
        #[prost(message, tag = "14")]
        CompleteWorkflow(super::CompleteWorkflowCommand),
        #[prost(message, tag = "15")]
        FailWorkflow(super::FailWorkflowCommand),
        #[prost(message, tag = "16")]
        SuspendWorkflow(super::SuspendWorkflowCommand),
        #[prost(message, tag = "17")]
        CancelWorkflow(super::CancelWorkflowCommand),
        #[prost(message, tag = "18")]
        CreatePromise(super::CreatePromiseCommand),
        #[prost(message, tag = "19")]
        ResolvePromise(super::ResolvePromiseCommand),
        #[prost(message, tag = "20")]
        ScheduleChildWorkflow(super::ScheduleChildWorkflowCommand),
        #[prost(message, tag = "21")]
        StartTimer(super::StartTimerCommand),
        #[prost(message, tag = "22")]
        CancelTimer(super::CancelTimerCommand),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordOperationCommand {
    #[prost(string, tag = "1")]
    pub operation_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetStateCommand {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearStateCommand {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleTaskCommand {
    #[prost(string, tag = "1")]
    pub task_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Unique ID for this task execution, used to match completions
    #[prost(string, tag = "3")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteWorkflowCommand {
    #[prost(bytes = "vec", tag = "1")]
    pub output: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailWorkflowCommand {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub stack_trace: ::prost::alloc::string::String,
    /// CODE_BUG, WORKER_CRASH, TRANSIENT_ERROR, BUSINESS_LOGIC, MAX_RETRIES, DETERMINISM_VIOLATION
    #[prost(string, tag = "3")]
    pub failure_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendWorkflowCommand {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelWorkflowCommand {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePromiseCommand {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "2")]
    pub timeout_ms: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvePromiseCommand {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleChildWorkflowCommand {
    #[prost(string, tag = "1")]
    pub child_execution_name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub workflow_kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub workflow_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub child_workflow_execution_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "6")]
    pub task_queue: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub priority_seconds: i32,
}
/// Timer commands for durable sleep
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTimerCommand {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub duration_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTimerCommand {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitWorkflowCommandsRequest {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<WorkflowCommand>,
    #[prost(enumeration = "WorkflowStatus", tag = "3")]
    pub status: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerRegistrationRequest {
    /// Worker identity
    #[prost(string, tag = "1")]
    pub worker_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub worker_version: ::prost::alloc::string::String,
    /// "WORKFLOW", "TASK", "UNIFIED"
    #[prost(string, tag = "3")]
    pub worker_type: ::prost::alloc::string::String,
    /// Tenant and space
    #[prost(string, tag = "4")]
    pub tenant_id: ::prost::alloc::string::String,
    /// NULL = tenant-level (shared infrastructure)
    #[prost(string, optional, tag = "5")]
    pub space_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Connection info
    #[prost(string, tag = "6")]
    pub host_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub process_id: ::prost::alloc::string::String,
    /// Capabilities
    #[prost(message, repeated, tag = "8")]
    pub workflows: ::prost::alloc::vec::Vec<WorkflowCapability>,
    #[prost(message, repeated, tag = "9")]
    pub tasks: ::prost::alloc::vec::Vec<TaskCapability>,
    /// Metadata
    #[prost(bytes = "vec", tag = "10")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowCapability {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "4")]
    pub timeout_seconds: ::core::option::Option<i32>,
    #[prost(bool, tag = "5")]
    pub cancellable: bool,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "7")]
    pub retry_policy: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
    /// Code-first workflow versioning (added in workflow-versioning-implementation)
    ///
    /// Semantic version (e.g., "1.0.0", "1.2.3")
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    /// SHA-256 hash of workflow bytecode
    #[prost(string, tag = "10")]
    pub content_hash: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskCapability {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "4")]
    pub timeout_seconds: ::core::option::Option<i32>,
    #[prost(bool, tag = "5")]
    pub cancellable: bool,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "7")]
    pub retry_policy: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub input_schema: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "9")]
    pub output_schema: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "10")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerRegistrationResponse {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub success: bool,
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub workflow_conflicts: ::prost::alloc::vec::Vec<WorkflowConflict>,
    #[prost(message, repeated, tag = "5")]
    pub task_conflicts: ::prost::alloc::vec::Vec<TaskConflict>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowConflict {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub existing_worker_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskConflict {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub existing_worker_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHeartbeatRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub workflow_kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub task_kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "4")]
    pub health_info: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamEventType {
    Unspecified = 0,
    Token = 1,
    Progress = 2,
    Data = 3,
    Error = 4,
}
impl StreamEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StreamEventType::Unspecified => "STREAM_EVENT_TYPE_UNSPECIFIED",
            StreamEventType::Token => "TOKEN",
            StreamEventType::Progress => "PROGRESS",
            StreamEventType::Data => "DATA",
            StreamEventType::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TOKEN" => Some(Self::Token),
            "PROGRESS" => Some(Self::Progress),
            "DATA" => Some(Self::Data),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandType {
    Unspecified = 0,
    RecordOperation = 1,
    SetState = 2,
    ClearState = 3,
    ScheduleTask = 4,
    CompleteWorkflow = 5,
    FailWorkflow = 6,
    SuspendWorkflow = 7,
    CancelWorkflow = 8,
    CreatePromise = 9,
    ResolvePromise = 10,
    ScheduleChildWorkflow = 11,
    StartTimer = 12,
    CancelTimer = 13,
}
impl CommandType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CommandType::Unspecified => "COMMAND_TYPE_UNSPECIFIED",
            CommandType::RecordOperation => "RECORD_OPERATION",
            CommandType::SetState => "SET_STATE",
            CommandType::ClearState => "CLEAR_STATE",
            CommandType::ScheduleTask => "SCHEDULE_TASK",
            CommandType::CompleteWorkflow => "COMPLETE_WORKFLOW",
            CommandType::FailWorkflow => "FAIL_WORKFLOW",
            CommandType::SuspendWorkflow => "SUSPEND_WORKFLOW",
            CommandType::CancelWorkflow => "CANCEL_WORKFLOW",
            CommandType::CreatePromise => "CREATE_PROMISE",
            CommandType::ResolvePromise => "RESOLVE_PROMISE",
            CommandType::ScheduleChildWorkflow => "SCHEDULE_CHILD_WORKFLOW",
            CommandType::StartTimer => "START_TIMER",
            CommandType::CancelTimer => "CANCEL_TIMER",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RECORD_OPERATION" => Some(Self::RecordOperation),
            "SET_STATE" => Some(Self::SetState),
            "CLEAR_STATE" => Some(Self::ClearState),
            "SCHEDULE_TASK" => Some(Self::ScheduleTask),
            "COMPLETE_WORKFLOW" => Some(Self::CompleteWorkflow),
            "FAIL_WORKFLOW" => Some(Self::FailWorkflow),
            "SUSPEND_WORKFLOW" => Some(Self::SuspendWorkflow),
            "CANCEL_WORKFLOW" => Some(Self::CancelWorkflow),
            "CREATE_PROMISE" => Some(Self::CreatePromise),
            "RESOLVE_PROMISE" => Some(Self::ResolvePromise),
            "SCHEDULE_CHILD_WORKFLOW" => Some(Self::ScheduleChildWorkflow),
            "START_TIMER" => Some(Self::StartTimer),
            "CANCEL_TIMER" => Some(Self::CancelTimer),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowStatus {
    Unspecified = 0,
    Running = 1,
    Suspended = 2,
    Completed = 3,
    Cancelled = 4,
    Failed = 5,
}
impl WorkflowStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkflowStatus::Unspecified => "WORKFLOW_STATUS_UNSPECIFIED",
            WorkflowStatus::Running => "RUNNING",
            WorkflowStatus::Suspended => "SUSPENDED",
            WorkflowStatus::Completed => "COMPLETED",
            WorkflowStatus::Cancelled => "CANCELLED",
            WorkflowStatus::Failed => "FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "RUNNING" => Some(Self::Running),
            "SUSPENDED" => Some(Self::Suspended),
            "COMPLETED" => Some(Self::Completed),
            "CANCELLED" => Some(Self::Cancelled),
            "FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod workflow_dispatch_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkflowDispatchClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkflowDispatchClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkflowDispatchClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowDispatchClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            WorkflowDispatchClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Poll for workflows (unary RPC with long polling)
        /// Worker calls this repeatedly to receive work
        pub async fn poll_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::PollRequest>,
        ) -> std::result::Result<tonic::Response<super::PollResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/PollWorkflow");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "PollWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to work-available notifications (server-to-client stream)
        /// Worker maintains this stream to receive instant notifications
        pub async fn subscribe_to_notifications(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WorkAvailableEvent>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/SubscribeToNotifications",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "SubscribeToNotifications",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Start workflow programmatically
        pub async fn start_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::StartWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/StartWorkflow");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "StartWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get visual workflow definition by ID (for lazy loading)
        pub async fn get_visual_workflow_definition_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVisualWorkflowDefinitionByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVisualWorkflowDefinitionByIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/GetVisualWorkflowDefinitionById",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "GetVisualWorkflowDefinitionById",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Start a child workflow
        pub async fn start_child_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::StartChildWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::StartChildWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/StartChildWorkflow",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "StartChildWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Resolve a durable promise
        pub async fn resolve_promise(
            &mut self,
            request: impl tonic::IntoRequest<super::ResolvePromiseRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/ResolvePromise");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "ResolvePromise",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Reject a durable promise
        pub async fn reject_promise(
            &mut self,
            request: impl tonic::IntoRequest<super::RejectPromiseRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/RejectPromise");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "RejectPromise",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get workflow events (for replay)
        pub async fn get_events(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetEventsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/GetEvents");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.WorkflowDispatch", "GetEvents"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit workflow commands after execution
        pub async fn submit_workflow_commands(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitWorkflowCommandsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/SubmitWorkflowCommands",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "SubmitWorkflowCommands",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod workflow_query_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkflowQueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkflowQueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkflowQueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowQueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            WorkflowQueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query workflow state
        pub async fn query_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowQuery/QueryWorkflow");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.WorkflowQuery", "QueryWorkflow"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod task_execution_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct TaskExecutionClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TaskExecutionClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TaskExecutionClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaskExecutionClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            TaskExecutionClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submit a task for execution
        pub async fn submit_task(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTaskResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/SubmitTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "SubmitTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Poll for tasks to execute (long polling)
        pub async fn poll_task(
            &mut self,
            request: impl tonic::IntoRequest<super::PollTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::PollTaskResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/PollTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "PollTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Complete a task
        pub async fn complete_task(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteTaskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/CompleteTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "CompleteTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Fail a task
        pub async fn fail_task(
            &mut self,
            request: impl tonic::IntoRequest<super::FailTaskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/FailTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "FailTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Report task progress
        pub async fn report_progress(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportProgressRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/ReportProgress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "ReportProgress"));
            self.inner.unary(req, path, codec).await
        }
        /// Send heartbeat
        pub async fn heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::HeartbeatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/Heartbeat");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "Heartbeat"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel a task
        pub async fn cancel_task(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelTaskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/CancelTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "CancelTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Log a message
        pub async fn log_message(
            &mut self,
            request: impl tonic::IntoRequest<super::LogMessageRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/LogMessage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "LogMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// Get task state value
        pub async fn get_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStateRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/GetState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "GetState"));
            self.inner.unary(req, path, codec).await
        }
        /// Set task state value
        pub async fn set_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SetStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/SetState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "SetState"));
            self.inner.unary(req, path, codec).await
        }
        /// Clear task state value
        pub async fn clear_state(
            &mut self,
            request: impl tonic::IntoRequest<super::ClearStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/ClearState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "ClearState"));
            self.inner.unary(req, path, codec).await
        }
        /// Clear all task state
        pub async fn clear_all_state(
            &mut self,
            request: impl tonic::IntoRequest<super::ClearAllStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/ClearAllState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "ClearAllState"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all state keys
        pub async fn get_state_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStateKeysRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStateKeysResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/GetStateKeys");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "GetStateKeys"));
            self.inner.unary(req, path, codec).await
        }
        /// Stream task data (tokens, progress, etc.)
        pub async fn stream_task_data(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamTaskDataRequest>,
        ) -> std::result::Result<tonic::Response<super::StreamTaskDataResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/StreamTaskData");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "StreamTaskData"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod worker_lifecycle_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkerLifecycleClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkerLifecycleClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkerLifecycleClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkerLifecycleClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            WorkerLifecycleClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Register worker with workflows and tasks
        pub async fn register_worker(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkerRegistrationRequest>,
        ) -> std::result::Result<tonic::Response<super::WorkerRegistrationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkerLifecycle/RegisterWorker");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkerLifecycle",
                "RegisterWorker",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Send heartbeat to update worker status
        pub async fn send_heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkerHeartbeatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkerLifecycle/SendHeartbeat");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkerLifecycle",
                "SendHeartbeat",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
