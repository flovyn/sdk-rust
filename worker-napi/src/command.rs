//! NAPI workflow command types.
//!
//! These commands are generated by the Node.js SDK during workflow execution
//! and sent back to the core for processing.

use uuid::Uuid;

/// Workflow commands that can be generated during execution.
#[derive(Debug, Clone)]
pub enum NapiWorkflowCommand {
    /// Record the result of a deterministic operation.
    RecordOperation {
        /// Unique operation name for replay matching.
        operation_name: String,
        /// Serialized result as JSON bytes.
        result: Vec<u8>,
    },

    /// Set workflow state.
    SetState {
        /// State key.
        key: String,
        /// Serialized value as JSON bytes.
        value: Vec<u8>,
    },

    /// Clear a workflow state key.
    ClearState {
        /// State key to clear.
        key: String,
    },

    /// Schedule a task for execution.
    ScheduleTask {
        /// Unique task execution ID.
        task_execution_id: String,
        /// Task kind.
        kind: String,
        /// Serialized input as JSON bytes.
        input: Vec<u8>,
        /// Optional priority in seconds.
        priority_seconds: Option<i32>,
        /// Optional max retries.
        max_retries: Option<u32>,
        /// Optional timeout in milliseconds.
        timeout_ms: Option<i64>,
        /// Optional queue name.
        queue: Option<String>,
        /// Optional idempotency key.
        idempotency_key: Option<String>,
        /// Optional TTL for idempotency key in seconds.
        idempotency_key_ttl_seconds: Option<i64>,
    },

    /// Schedule a child workflow.
    ScheduleChildWorkflow {
        /// Child workflow name.
        name: String,
        /// Optional workflow kind.
        kind: Option<String>,
        /// Child execution ID.
        child_execution_id: String,
        /// Serialized input as JSON bytes.
        input: Vec<u8>,
        /// Task queue for the child.
        queue: String,
        /// Priority in seconds.
        priority_seconds: i32,
    },

    /// Complete the workflow successfully.
    CompleteWorkflow {
        /// Serialized output as JSON bytes.
        output: Vec<u8>,
    },

    /// Fail the workflow with an error.
    FailWorkflow {
        /// Error message.
        error: String,
        /// Stack trace (optional).
        stack_trace: String,
        /// Failure type (optional).
        failure_type: Option<String>,
    },

    /// Suspend the workflow.
    SuspendWorkflow {
        /// Reason for suspension.
        reason: String,
    },

    /// Cancel the workflow.
    CancelWorkflow {
        /// Reason for cancellation.
        reason: String,
    },

    /// Create a durable promise.
    CreatePromise {
        /// Promise ID.
        promise_id: String,
        /// Optional timeout in milliseconds.
        timeout_ms: Option<i64>,
        /// Optional idempotency key.
        idempotency_key: Option<String>,
        /// TTL for the idempotency key in seconds.
        idempotency_key_ttl_seconds: Option<i64>,
    },

    /// Resolve a durable promise.
    ResolvePromise {
        /// Promise ID.
        promise_id: String,
        /// Serialized value as JSON bytes.
        value: Vec<u8>,
    },

    /// Start a timer.
    StartTimer {
        /// Timer ID.
        timer_id: String,
        /// Duration in milliseconds.
        duration_ms: i64,
    },

    /// Cancel a timer.
    CancelTimer {
        /// Timer ID to cancel.
        timer_id: String,
    },

    /// Request cancellation of a task.
    RequestCancelTask {
        /// Task execution ID to cancel.
        task_execution_id: String,
    },

    /// Request cancellation of a child workflow.
    RequestCancelChildWorkflow {
        /// Child execution ID to cancel.
        child_execution_id: String,
    },
}

impl NapiWorkflowCommand {
    /// Convert command to JSON value for serialization.
    pub fn to_json(&self) -> serde_json::Value {
        use base64::Engine;
        match self {
            NapiWorkflowCommand::RecordOperation {
                operation_name,
                result,
            } => serde_json::json!({
                "type": "RecordOperation",
                "operationName": operation_name,
                "result": base64::engine::general_purpose::STANDARD.encode(result),
            }),
            NapiWorkflowCommand::SetState { key, value } => serde_json::json!({
                "type": "SetState",
                "key": key,
                "value": base64::engine::general_purpose::STANDARD.encode(value),
            }),
            NapiWorkflowCommand::ClearState { key } => serde_json::json!({
                "type": "ClearState",
                "key": key,
            }),
            NapiWorkflowCommand::ScheduleTask {
                task_execution_id,
                kind,
                input,
                priority_seconds,
                max_retries,
                timeout_ms,
                queue,
                idempotency_key,
                idempotency_key_ttl_seconds,
            } => serde_json::json!({
                "type": "ScheduleTask",
                "taskExecutionId": task_execution_id,
                "kind": kind,
                "input": base64::engine::general_purpose::STANDARD.encode(input),
                "prioritySeconds": priority_seconds,
                "maxRetries": max_retries,
                "timeoutMs": timeout_ms,
                "queue": queue,
                "idempotencyKey": idempotency_key,
                "idempotencyKeyTtlSeconds": idempotency_key_ttl_seconds,
            }),
            NapiWorkflowCommand::ScheduleChildWorkflow {
                name,
                kind,
                child_execution_id,
                input,
                queue,
                priority_seconds,
            } => serde_json::json!({
                "type": "ScheduleChildWorkflow",
                "name": name,
                "kind": kind,
                "childExecutionId": child_execution_id,
                "input": base64::engine::general_purpose::STANDARD.encode(input),
                "queue": queue,
                "prioritySeconds": priority_seconds,
            }),
            NapiWorkflowCommand::CompleteWorkflow { output } => serde_json::json!({
                "type": "CompleteWorkflow",
                "output": base64::engine::general_purpose::STANDARD.encode(output),
            }),
            NapiWorkflowCommand::FailWorkflow {
                error,
                stack_trace,
                failure_type,
            } => serde_json::json!({
                "type": "FailWorkflow",
                "error": error,
                "stackTrace": stack_trace,
                "failureType": failure_type,
            }),
            NapiWorkflowCommand::SuspendWorkflow { reason } => serde_json::json!({
                "type": "SuspendWorkflow",
                "reason": reason,
            }),
            NapiWorkflowCommand::CancelWorkflow { reason } => serde_json::json!({
                "type": "CancelWorkflow",
                "reason": reason,
            }),
            NapiWorkflowCommand::CreatePromise {
                promise_id,
                timeout_ms,
                idempotency_key,
                idempotency_key_ttl_seconds,
            } => serde_json::json!({
                "type": "CreatePromise",
                "promiseId": promise_id,
                "timeoutMs": timeout_ms,
                "idempotencyKey": idempotency_key,
                "idempotencyKeyTtlSeconds": idempotency_key_ttl_seconds,
            }),
            NapiWorkflowCommand::ResolvePromise { promise_id, value } => serde_json::json!({
                "type": "ResolvePromise",
                "promiseId": promise_id,
                "value": base64::engine::general_purpose::STANDARD.encode(value),
            }),
            NapiWorkflowCommand::StartTimer {
                timer_id,
                duration_ms,
            } => serde_json::json!({
                "type": "StartTimer",
                "timerId": timer_id,
                "durationMs": duration_ms,
            }),
            NapiWorkflowCommand::CancelTimer { timer_id } => serde_json::json!({
                "type": "CancelTimer",
                "timerId": timer_id,
            }),
            NapiWorkflowCommand::RequestCancelTask { task_execution_id } => serde_json::json!({
                "type": "RequestCancelTask",
                "taskExecutionId": task_execution_id,
            }),
            NapiWorkflowCommand::RequestCancelChildWorkflow { child_execution_id } => {
                serde_json::json!({
                    "type": "RequestCancelChildWorkflow",
                    "childExecutionId": child_execution_id,
                })
            }
        }
    }

    /// Convert to proto WorkflowCommand for gRPC submission.
    pub fn to_proto_command(
        &self,
        sequence_number: i32,
    ) -> flovyn_worker_core::generated::flovyn_v1::WorkflowCommand {
        use flovyn_worker_core::generated::flovyn_v1::{self, workflow_command::CommandData};

        let (command_type, command_data) = match self {
            NapiWorkflowCommand::RecordOperation {
                operation_name,
                result,
            } => (
                flovyn_v1::CommandType::RecordOperation as i32,
                Some(CommandData::RecordOperation(
                    flovyn_v1::RecordOperationCommand {
                        operation_name: operation_name.clone(),
                        result: result.clone(),
                    },
                )),
            ),
            NapiWorkflowCommand::SetState { key, value } => (
                flovyn_v1::CommandType::SetState as i32,
                Some(CommandData::SetState(flovyn_v1::SetStateCommand {
                    key: key.clone(),
                    value: value.clone(),
                })),
            ),
            NapiWorkflowCommand::ClearState { key } => (
                flovyn_v1::CommandType::ClearState as i32,
                Some(CommandData::ClearState(flovyn_v1::ClearStateCommand {
                    key: key.clone(),
                })),
            ),
            NapiWorkflowCommand::ScheduleTask {
                task_execution_id,
                kind,
                input,
                max_retries,
                timeout_ms,
                queue,
                priority_seconds,
                idempotency_key,
                idempotency_key_ttl_seconds,
            } => (
                flovyn_v1::CommandType::ScheduleTask as i32,
                Some(CommandData::ScheduleTask(flovyn_v1::ScheduleTaskCommand {
                    kind: kind.clone(),
                    input: input.clone(),
                    task_execution_id: task_execution_id.clone(),
                    max_retries: max_retries.map(|v| v as i32),
                    timeout_ms: *timeout_ms,
                    queue: queue.clone(),
                    priority_seconds: *priority_seconds,
                    idempotency_key: idempotency_key.clone(),
                    idempotency_key_ttl_seconds: *idempotency_key_ttl_seconds,
                })),
            ),
            NapiWorkflowCommand::ScheduleChildWorkflow {
                name,
                kind,
                child_execution_id,
                input,
                queue,
                priority_seconds,
            } => (
                flovyn_v1::CommandType::ScheduleChildWorkflow as i32,
                Some(CommandData::ScheduleChildWorkflow(
                    flovyn_v1::ScheduleChildWorkflowCommand {
                        child_execution_name: name.clone(),
                        workflow_kind: kind.clone(),
                        workflow_definition_id: None,
                        child_workflow_execution_id: child_execution_id.clone(),
                        input: input.clone(),
                        queue: queue.clone(),
                        priority_seconds: *priority_seconds,
                    },
                )),
            ),
            NapiWorkflowCommand::CompleteWorkflow { output } => (
                flovyn_v1::CommandType::CompleteWorkflow as i32,
                Some(CommandData::CompleteWorkflow(
                    flovyn_v1::CompleteWorkflowCommand {
                        output: output.clone(),
                    },
                )),
            ),
            NapiWorkflowCommand::FailWorkflow {
                error,
                stack_trace,
                failure_type,
            } => (
                flovyn_v1::CommandType::FailWorkflow as i32,
                Some(CommandData::FailWorkflow(flovyn_v1::FailWorkflowCommand {
                    error: error.clone(),
                    stack_trace: stack_trace.clone(),
                    failure_type: failure_type.clone().unwrap_or_default(),
                })),
            ),
            NapiWorkflowCommand::SuspendWorkflow { reason } => (
                flovyn_v1::CommandType::SuspendWorkflow as i32,
                Some(CommandData::SuspendWorkflow(
                    flovyn_v1::SuspendWorkflowCommand {
                        reason: reason.clone(),
                    },
                )),
            ),
            NapiWorkflowCommand::CancelWorkflow { reason } => (
                flovyn_v1::CommandType::CancelWorkflow as i32,
                Some(CommandData::CancelWorkflow(
                    flovyn_v1::CancelWorkflowCommand {
                        reason: reason.clone(),
                    },
                )),
            ),
            NapiWorkflowCommand::CreatePromise {
                promise_id,
                timeout_ms,
                idempotency_key,
                idempotency_key_ttl_seconds,
            } => (
                flovyn_v1::CommandType::CreatePromise as i32,
                Some(CommandData::CreatePromise(
                    flovyn_v1::CreatePromiseCommand {
                        promise_id: promise_id.clone(),
                        timeout_ms: *timeout_ms,
                        idempotency_key: idempotency_key.clone(),
                        idempotency_key_ttl_seconds: *idempotency_key_ttl_seconds,
                    },
                )),
            ),
            NapiWorkflowCommand::ResolvePromise { promise_id, value } => (
                flovyn_v1::CommandType::ResolvePromise as i32,
                Some(CommandData::ResolvePromise(
                    flovyn_v1::ResolvePromiseCommand {
                        promise_id: promise_id.clone(),
                        value: value.clone(),
                    },
                )),
            ),
            NapiWorkflowCommand::StartTimer {
                timer_id,
                duration_ms,
            } => (
                flovyn_v1::CommandType::StartTimer as i32,
                Some(CommandData::StartTimer(flovyn_v1::StartTimerCommand {
                    timer_id: timer_id.clone(),
                    duration_ms: *duration_ms,
                })),
            ),
            NapiWorkflowCommand::CancelTimer { timer_id } => (
                flovyn_v1::CommandType::CancelTimer as i32,
                Some(CommandData::CancelTimer(flovyn_v1::CancelTimerCommand {
                    timer_id: timer_id.clone(),
                })),
            ),
            NapiWorkflowCommand::RequestCancelTask {
                task_execution_id: _,
            } => {
                // RequestCancelTask is not yet supported in proto
                (flovyn_v1::CommandType::Unspecified as i32, None)
            }
            NapiWorkflowCommand::RequestCancelChildWorkflow { child_execution_id } => (
                flovyn_v1::CommandType::RequestCancelChildWorkflow as i32,
                Some(CommandData::RequestCancelChildWorkflow(
                    flovyn_v1::RequestCancelChildWorkflowCommand {
                        child_execution_name: String::new(),
                        child_workflow_execution_id: child_execution_id.clone(),
                        reason: String::new(),
                    },
                )),
            ),
        };

        flovyn_v1::WorkflowCommand {
            sequence_number,
            command_type,
            command_data,
        }
    }

    /// Convert to core WorkflowCommand with a sequence number.
    pub fn to_core_command(&self, sequence_number: i32) -> flovyn_worker_core::WorkflowCommand {
        use flovyn_worker_core::WorkflowCommand;

        match self {
            NapiWorkflowCommand::RecordOperation {
                operation_name,
                result,
            } => WorkflowCommand::RecordOperation {
                sequence_number,
                operation_name: operation_name.clone(),
                result: serde_json::from_slice(result).unwrap_or(serde_json::Value::Null),
            },
            NapiWorkflowCommand::SetState { key, value } => WorkflowCommand::SetState {
                sequence_number,
                key: key.clone(),
                value: serde_json::from_slice(value).unwrap_or(serde_json::Value::Null),
            },
            NapiWorkflowCommand::ClearState { key } => WorkflowCommand::ClearState {
                sequence_number,
                key: key.clone(),
            },
            NapiWorkflowCommand::ScheduleTask {
                task_execution_id,
                kind,
                input,
                priority_seconds,
                max_retries,
                timeout_ms,
                queue,
                idempotency_key,
                idempotency_key_ttl_seconds,
            } => WorkflowCommand::ScheduleTask {
                sequence_number,
                kind: kind.clone(),
                task_execution_id: Uuid::parse_str(task_execution_id)
                    .unwrap_or_else(|_| Uuid::nil()),
                input: serde_json::from_slice(input).unwrap_or(serde_json::Value::Null),
                priority_seconds: *priority_seconds,
                max_retries: *max_retries,
                timeout_ms: *timeout_ms,
                queue: queue.clone(),
                idempotency_key: idempotency_key.clone(),
                idempotency_key_ttl_seconds: *idempotency_key_ttl_seconds,
            },
            NapiWorkflowCommand::ScheduleChildWorkflow {
                name,
                kind,
                child_execution_id,
                input,
                queue,
                priority_seconds,
            } => WorkflowCommand::ScheduleChildWorkflow {
                sequence_number,
                name: name.clone(),
                kind: kind.clone(),
                definition_id: None,
                child_execution_id: Uuid::parse_str(child_execution_id)
                    .unwrap_or_else(|_| Uuid::nil()),
                input: serde_json::from_slice(input).unwrap_or(serde_json::Value::Null),
                queue: queue.clone(),
                priority_seconds: *priority_seconds,
            },
            NapiWorkflowCommand::CompleteWorkflow { output } => WorkflowCommand::CompleteWorkflow {
                sequence_number,
                output: serde_json::from_slice(output).unwrap_or(serde_json::Value::Null),
            },
            NapiWorkflowCommand::FailWorkflow {
                error,
                stack_trace,
                failure_type,
            } => WorkflowCommand::FailWorkflow {
                sequence_number,
                error: error.clone(),
                stack_trace: stack_trace.clone(),
                failure_type: failure_type.clone(),
            },
            NapiWorkflowCommand::SuspendWorkflow { reason } => WorkflowCommand::SuspendWorkflow {
                sequence_number,
                reason: reason.clone(),
            },
            NapiWorkflowCommand::CancelWorkflow { reason } => WorkflowCommand::CancelWorkflow {
                sequence_number,
                reason: reason.clone(),
            },
            NapiWorkflowCommand::CreatePromise {
                promise_id,
                timeout_ms,
                idempotency_key,
                idempotency_key_ttl_seconds,
            } => WorkflowCommand::CreatePromise {
                sequence_number,
                promise_id: promise_id.clone(),
                timeout_ms: *timeout_ms,
                idempotency_key: idempotency_key.clone(),
                idempotency_key_ttl_seconds: *idempotency_key_ttl_seconds,
            },
            NapiWorkflowCommand::ResolvePromise { promise_id, value } => {
                WorkflowCommand::ResolvePromise {
                    sequence_number,
                    promise_id: promise_id.clone(),
                    value: serde_json::from_slice(value).unwrap_or(serde_json::Value::Null),
                }
            }
            NapiWorkflowCommand::StartTimer {
                timer_id,
                duration_ms,
            } => WorkflowCommand::StartTimer {
                sequence_number,
                timer_id: timer_id.clone(),
                duration_ms: *duration_ms,
            },
            NapiWorkflowCommand::CancelTimer { timer_id } => WorkflowCommand::CancelTimer {
                sequence_number,
                timer_id: timer_id.clone(),
            },
            NapiWorkflowCommand::RequestCancelTask { task_execution_id } => {
                WorkflowCommand::RequestCancelTask {
                    sequence_number,
                    task_execution_id: Uuid::parse_str(task_execution_id)
                        .unwrap_or_else(|_| Uuid::nil()),
                }
            }
            NapiWorkflowCommand::RequestCancelChildWorkflow { child_execution_id } => {
                WorkflowCommand::RequestCancelChildWorkflow {
                    sequence_number,
                    child_execution_id: Uuid::parse_str(child_execution_id)
                        .unwrap_or_else(|_| Uuid::nil()),
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_record_operation_conversion() {
        let cmd = NapiWorkflowCommand::RecordOperation {
            operation_name: "test-op".to_string(),
            result: b"42".to_vec(),
        };
        let core_cmd = cmd.to_core_command(1);
        assert!(matches!(
            core_cmd,
            flovyn_worker_core::WorkflowCommand::RecordOperation {
                sequence_number: 1,
                ..
            }
        ));
    }

    #[test]
    fn test_schedule_task_conversion() {
        let cmd = NapiWorkflowCommand::ScheduleTask {
            task_execution_id: Uuid::nil().to_string(),
            kind: "my-task".to_string(),
            input: b"{}".to_vec(),
            priority_seconds: Some(30),
            max_retries: Some(3),
            timeout_ms: Some(60000),
            queue: Some("high-priority".to_string()),
            idempotency_key: None,
            idempotency_key_ttl_seconds: None,
        };
        let core_cmd = cmd.to_core_command(5);
        assert!(matches!(
            core_cmd,
            flovyn_worker_core::WorkflowCommand::ScheduleTask {
                sequence_number: 5,
                ..
            }
        ));
    }
}
