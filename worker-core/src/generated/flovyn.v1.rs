// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollRequest {
    /// Unique identifier for this worker
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    /// Organization ID to poll workflows from
    #[prost(string, tag = "2")]
    pub org_id: ::prost::alloc::string::String,
    /// Queue to poll from (e.g., "default", "gpu-workers")
    #[prost(string, tag = "3")]
    pub queue: ::prost::alloc::string::String,
    /// Long polling timeout in seconds (e.g., 60)
    #[prost(int64, tag = "4")]
    pub timeout_seconds: i64,
    /// Worker pool ID to poll from (NULL = default shared pool)
    #[prost(string, optional, tag = "5")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Workflow kinds this worker can handle (empty = all kinds)
    #[prost(string, repeated, tag = "6")]
    pub workflow_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscriptionRequest {
    /// Unique identifier for this worker
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    /// Organization ID to subscribe to
    #[prost(string, tag = "2")]
    pub org_id: ::prost::alloc::string::String,
    /// Queue to subscribe to
    #[prost(string, tag = "3")]
    pub queue: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollResponse {
    /// Workflow to execute (null if no work available)
    #[prost(message, optional, tag = "1")]
    pub workflow_execution: ::core::option::Option<WorkflowExecution>,
    /// W3C Trace Context traceparent for distributed tracing
    #[prost(string, tag = "2")]
    pub traceparent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowExecution {
    /// Unique workflow execution ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Workflow kind/type
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// Organization ID
    #[prost(string, tag = "3")]
    pub org_id: ::prost::alloc::string::String,
    /// Input data (serialized bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Queue for worker routing (e.g., "default", "gpu-workers")
    #[prost(string, tag = "5")]
    pub queue: ::prost::alloc::string::String,
    /// Time-offset priority in milliseconds (priority score = created_at - priority_ms)
    #[prost(int64, tag = "6")]
    pub priority_ms: i64,
    /// Creation timestamp (milliseconds since epoch)
    #[prost(int64, tag = "7")]
    pub created_at_ms: i64,
    /// Current sequence number for event sourcing
    #[prost(int32, tag = "8")]
    pub current_sequence: i32,
    /// Visual workflow definition ID (if this is a visual workflow)
    #[prost(string, optional, tag = "9")]
    pub workflow_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Team ID (if workflow is scoped to a team)
    #[prost(string, optional, tag = "10")]
    pub team_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Worker pool ID (denormalized for dispatch efficiency)
    #[prost(string, optional, tag = "11")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Locked workflow version (Phase 9: Version Locking)
    /// For code-first: semantic version (e.g., "1.0.0")
    /// For visual: version number as string (e.g., "1", "2")
    #[prost(string, optional, tag = "12")]
    pub workflow_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Workflow definition snapshot (Phase 9: Version Locking)
    /// Cached JSON definition for version isolation (visual workflows only)
    #[prost(string, optional, tag = "13")]
    pub workflow_definition_snapshot: ::core::option::Option<::prost::alloc::string::String>,
    /// Time when this workflow task was created (milliseconds since epoch)
    /// Used for deterministic ctx.currentTimeMillis()
    /// This value is consistent across replays for the same workflow task
    #[prost(int64, tag = "14")]
    pub workflow_task_time_millis: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAvailableEvent {
    /// Organization ID where work is available
    #[prost(string, tag = "1")]
    pub org_id: ::prost::alloc::string::String,
    /// Queue where work is available
    #[prost(string, tag = "2")]
    pub queue: ::prost::alloc::string::String,
    /// Timestamp of notification (milliseconds since epoch)
    #[prost(int64, tag = "3")]
    pub timestamp_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowRequest {
    #[prost(string, tag = "1")]
    pub org_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_kind: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Arbitrary key-value metadata for tracking, filtering, and analytics
    #[prost(map = "string, string", tag = "4")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// Queue routing (default: "default")
    #[prost(string, tag = "5")]
    pub queue: ::prost::alloc::string::String,
    /// Time-offset priority in seconds (default: 0)
    #[prost(int32, tag = "6")]
    pub priority_seconds: i32,
    #[prost(string, optional, tag = "7")]
    pub workflow_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "8")]
    pub parent_workflow_execution_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Workflow version selection (Phase 9: Version Locking)
    /// For code-first: semantic version (e.g., "1.0.0"), empty = latest/default
    /// For visual: version number as string (e.g., "1", "2"), empty = latest
    #[prost(string, optional, tag = "9")]
    pub workflow_version: ::core::option::Option<::prost::alloc::string::String>,
    /// Idempotency key for preventing duplicate executions
    /// If provided, subsequent requests with the same key return the existing execution
    #[prost(string, optional, tag = "10")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// Time-to-live for the idempotency key in seconds
    /// Default: 86400 (1 day), Maximum: 2592000 (30 days)
    #[prost(int64, optional, tag = "11")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartWorkflowResponse {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    /// Whether an idempotency key was used for this request
    #[prost(bool, tag = "2")]
    pub idempotency_key_used: bool,
    /// Whether a new execution was created (false means existing execution was returned)
    #[prost(bool, tag = "3")]
    pub idempotency_key_new: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVisualWorkflowDefinitionByIdRequest {
    #[prost(string, tag = "1")]
    pub workflow_definition_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetVisualWorkflowDefinitionByIdResponse {
    #[prost(string, tag = "1")]
    pub workflow_definition_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub description: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub definition: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub version: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowRequest {
    #[prost(string, tag = "1")]
    pub parent_workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub child_execution_name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub org_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "6")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Queue (inherits parent if empty)
    #[prost(string, tag = "7")]
    pub queue: ::prost::alloc::string::String,
    /// Time-offset priority in seconds (default: 0)
    #[prost(int32, tag = "8")]
    pub priority_seconds: i32,
    #[prost(
        oneof = "start_child_workflow_request::WorkflowExecutionIdentifier",
        tags = "4, 5"
    )]
    pub workflow_execution_identifier:
        ::core::option::Option<start_child_workflow_request::WorkflowExecutionIdentifier>,
}
/// Nested message and enum types in `StartChildWorkflowRequest`.
pub mod start_child_workflow_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WorkflowExecutionIdentifier {
        #[prost(string, tag = "4")]
        WorkflowKind(::prost::alloc::string::String),
        #[prost(string, tag = "5")]
        WorkflowDefinitionId(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartChildWorkflowResponse {
    #[prost(string, tag = "1")]
    pub child_workflow_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvePromiseRequest {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RejectPromiseRequest {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowRequest {
    #[prost(string, tag = "1")]
    pub org_id: ::prost::alloc::string::String,
    /// === Workflow Identity ===
    ///
    /// Used as idempotency key for workflow creation
    #[prost(string, tag = "2")]
    pub workflow_id: ::prost::alloc::string::String,
    /// === Workflow Parameters (used only when creating) ===
    #[prost(string, tag = "3")]
    pub workflow_kind: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub workflow_input: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub queue: ::prost::alloc::string::String,
    #[prost(int32, tag = "6")]
    pub priority_seconds: i32,
    #[prost(string, optional, tag = "7")]
    pub workflow_version: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(map = "string, string", tag = "8")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    /// === Signal Parameters (always applied) ===
    #[prost(string, tag = "9")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "10")]
    pub signal_value: ::prost::alloc::vec::Vec<u8>,
    /// === Options ===
    #[prost(int64, optional, tag = "11")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWithStartWorkflowResponse {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub workflow_created: bool,
    #[prost(int64, tag = "3")]
    pub signal_event_sequence: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWorkflowRequest {
    #[prost(string, tag = "1")]
    pub org_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub signal_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub signal_value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalWorkflowResponse {
    #[prost(int64, tag = "1")]
    pub signal_event_sequence: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsRequest {
    /// Workflow execution ID
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEventsResponse {
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<WorkflowEvent>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowEvent {
    /// Sequence number
    #[prost(int32, tag = "1")]
    pub sequence_number: i32,
    /// Event type (e.g., "TASK_SCHEDULED", "TASK_COMPLETED")
    #[prost(string, tag = "2")]
    pub event_type: ::prost::alloc::string::String,
    /// Event data (JSON structure)
    #[prost(bytes = "vec", tag = "3")]
    pub event_data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowRequest {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub query_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub params: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryWorkflowResponse {
    #[prost(bytes = "vec", tag = "1")]
    pub result: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, optional, tag = "2")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTaskRequest {
    /// Optional for standalone tasks (empty string = standalone)
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub org_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub kind: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Arbitrary key-value metadata for tracking, filtering, and analytics
    #[prost(map = "string, string", tag = "5")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(int32, tag = "6")]
    pub max_retries: i32,
    #[prost(int64, tag = "7")]
    pub timeout_ms: i64,
    /// Idempotency key to prevent duplicate task executions
    #[prost(string, optional, tag = "8")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// TTL for the idempotency key in seconds (default: 1 day, max: 30 days)
    #[prost(int64, optional, tag = "9")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
    /// Queue for task routing (default: "default")
    #[prost(string, tag = "10")]
    pub queue: ::prost::alloc::string::String,
    /// Worker pool ID for tenant isolation (empty = any pool)
    #[prost(string, optional, tag = "11")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitTaskResponse {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    /// Whether an idempotency key was used for this request
    #[prost(bool, tag = "2")]
    pub idempotency_key_used: bool,
    /// Whether a new task execution was created (false if existing execution was returned)
    #[prost(bool, tag = "3")]
    pub idempotency_key_new: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollTaskRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub org_id: ::prost::alloc::string::String,
    #[prost(map = "string, string", tag = "3")]
    pub worker_labels:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
    #[prost(int64, tag = "4")]
    pub timeout_seconds: i64,
    /// Queue to poll tasks from (default: "default")
    #[prost(string, tag = "5")]
    pub queue: ::prost::alloc::string::String,
    /// Worker pool ID for tenant isolation (empty = any pool)
    #[prost(string, optional, tag = "6")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollTaskResponse {
    #[prost(message, optional, tag = "1")]
    pub task: ::core::option::Option<TaskExecutionInfo>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskExecutionInfo {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Empty string for standalone tasks
    #[prost(string, tag = "4")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "5")]
    pub execution_count: i32,
    /// Queue this task belongs to
    #[prost(string, tag = "6")]
    pub queue: ::prost::alloc::string::String,
    /// Worker pool ID (empty = shared pool)
    #[prost(string, optional, tag = "7")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
    /// W3C Trace Context traceparent for distributed tracing
    #[prost(string, tag = "8")]
    pub traceparent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteTaskRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub output: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailTaskRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportProgressRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(double, tag = "2")]
    pub progress: f64,
    #[prost(string, tag = "3")]
    pub details: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HeartbeatRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTaskRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LogMessageRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub level: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateResponse {
    /// Value as JSON (null if not found)
    #[prost(bytes = "vec", tag = "1")]
    pub value: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "2")]
    pub found: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearAllStateRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateKeysRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetStateKeysResponse {
    #[prost(string, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamTaskDataRequest {
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub sequence: i32,
    #[prost(enumeration = "StreamEventType", tag = "4")]
    pub r#type: i32,
    #[prost(string, tag = "5")]
    pub payload: ::prost::alloc::string::String,
    #[prost(int64, tag = "6")]
    pub timestamp_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamTaskDataResponse {
    #[prost(bool, tag = "1")]
    pub acknowledged: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowCommand {
    #[prost(enumeration = "CommandType", tag = "1")]
    pub command_type: i32,
    #[prost(int32, tag = "2")]
    pub sequence_number: i32,
    #[prost(
        oneof = "workflow_command::CommandData",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23"
    )]
    pub command_data: ::core::option::Option<workflow_command::CommandData>,
}
/// Nested message and enum types in `WorkflowCommand`.
pub mod workflow_command {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum CommandData {
        #[prost(message, tag = "10")]
        RecordOperation(super::RecordOperationCommand),
        #[prost(message, tag = "11")]
        SetState(super::SetStateCommand),
        #[prost(message, tag = "12")]
        ClearState(super::ClearStateCommand),
        #[prost(message, tag = "13")]
        ScheduleTask(super::ScheduleTaskCommand),
        #[prost(message, tag = "14")]
        CompleteWorkflow(super::CompleteWorkflowCommand),
        #[prost(message, tag = "15")]
        FailWorkflow(super::FailWorkflowCommand),
        #[prost(message, tag = "16")]
        SuspendWorkflow(super::SuspendWorkflowCommand),
        #[prost(message, tag = "17")]
        CancelWorkflow(super::CancelWorkflowCommand),
        #[prost(message, tag = "18")]
        CreatePromise(super::CreatePromiseCommand),
        #[prost(message, tag = "19")]
        ResolvePromise(super::ResolvePromiseCommand),
        #[prost(message, tag = "20")]
        ScheduleChildWorkflow(super::ScheduleChildWorkflowCommand),
        #[prost(message, tag = "21")]
        StartTimer(super::StartTimerCommand),
        #[prost(message, tag = "22")]
        CancelTimer(super::CancelTimerCommand),
        #[prost(message, tag = "23")]
        RequestCancelChildWorkflow(super::RequestCancelChildWorkflowCommand),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RecordOperationCommand {
    #[prost(string, tag = "1")]
    pub operation_name: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub result: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SetStateCommand {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClearStateCommand {
    #[prost(string, tag = "1")]
    pub key: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleTaskCommand {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Client-generated UUID for this task execution
    #[prost(string, tag = "3")]
    pub task_execution_id: ::prost::alloc::string::String,
    /// Optional task configuration (defaults from workflow if not specified)
    ///
    /// Default: 3
    #[prost(int32, optional, tag = "4")]
    pub max_retries: ::core::option::Option<i32>,
    /// Default: none (not yet implemented)
    #[prost(int64, optional, tag = "5")]
    pub timeout_ms: ::core::option::Option<i64>,
    /// Default: workflow's queue
    #[prost(string, optional, tag = "6")]
    pub queue: ::core::option::Option<::prost::alloc::string::String>,
    /// Default: 0 (not yet implemented for tasks)
    #[prost(int32, optional, tag = "7")]
    pub priority_seconds: ::core::option::Option<i32>,
    /// Idempotency key for external correlation (e.g., "job:batch_12345")
    #[prost(string, optional, tag = "8")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// TTL for idempotency key in seconds (default: 86400 = 24 hours)
    #[prost(int64, optional, tag = "9")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteWorkflowCommand {
    #[prost(bytes = "vec", tag = "1")]
    pub output: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailWorkflowCommand {
    #[prost(string, tag = "1")]
    pub error: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub stack_trace: ::prost::alloc::string::String,
    /// CODE_BUG, WORKER_CRASH, TRANSIENT_ERROR, BUSINESS_LOGIC, MAX_RETRIES, DETERMINISM_VIOLATION
    #[prost(string, tag = "3")]
    pub failure_type: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendWorkflowCommand {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelWorkflowCommand {
    #[prost(string, tag = "1")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CreatePromiseCommand {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(int64, optional, tag = "2")]
    pub timeout_ms: ::core::option::Option<i64>,
    /// Idempotency key for external correlation (e.g., "stripe:ch_abc123")
    #[prost(string, optional, tag = "3")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// TTL for idempotency key in seconds (default: 86400 = 24 hours)
    #[prost(int64, optional, tag = "4")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ResolvePromiseCommand {
    #[prost(string, tag = "1")]
    pub promise_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleChildWorkflowCommand {
    #[prost(string, tag = "1")]
    pub child_execution_name: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub workflow_kind: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, optional, tag = "3")]
    pub workflow_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub child_workflow_execution_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "5")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "6")]
    pub queue: ::prost::alloc::string::String,
    #[prost(int32, tag = "7")]
    pub priority_seconds: i32,
}
/// Timer commands for durable sleep
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StartTimerCommand {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub duration_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CancelTimerCommand {
    #[prost(string, tag = "1")]
    pub timer_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RequestCancelChildWorkflowCommand {
    #[prost(string, tag = "1")]
    pub child_execution_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub child_workflow_execution_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitWorkflowCommandsRequest {
    #[prost(string, tag = "1")]
    pub workflow_execution_id: ::prost::alloc::string::String,
    #[prost(message, repeated, tag = "2")]
    pub commands: ::prost::alloc::vec::Vec<WorkflowCommand>,
    #[prost(enumeration = "WorkflowStatus", tag = "3")]
    pub status: i32,
}
/// SDK execution metadata - sent with each span batch
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SdkInfo {
    /// "rust", "python", "typescript", "go", "java"
    #[prost(string, tag = "1")]
    pub language: ::prost::alloc::string::String,
    /// "0.1.0"
    #[prost(string, tag = "2")]
    pub sdk_version: ::prost::alloc::string::String,
    /// "1.75.0" (rustc), "3.12" (python), "20.x" (node)
    #[prost(string, optional, tag = "3")]
    pub runtime_version: ::core::option::Option<::prost::alloc::string::String>,
    /// "linux", "darwin", "windows"
    #[prost(string, optional, tag = "4")]
    pub os: ::core::option::Option<::prost::alloc::string::String>,
    /// "x86_64", "aarch64"
    #[prost(string, optional, tag = "5")]
    pub arch: ::core::option::Option<::prost::alloc::string::String>,
    /// for debugging which worker instance
    #[prost(string, optional, tag = "6")]
    pub hostname: ::core::option::Option<::prost::alloc::string::String>,
}
/// Individual execution span - only Flovyn-specific data
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExecutionSpan {
    /// Span identification
    ///
    /// generated by SDK
    #[prost(string, tag = "1")]
    pub span_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "2")]
    pub parent_span_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Span type (enum enforced by server)
    ///
    /// "workflow.execute", "task.execute", "task.retry"
    #[prost(string, tag = "3")]
    pub span_type: ::prost::alloc::string::String,
    /// Context
    #[prost(string, tag = "4")]
    pub workflow_id: ::prost::alloc::string::String,
    #[prost(string, optional, tag = "5")]
    pub task_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Timing (nanoseconds since Unix epoch)
    #[prost(int64, tag = "6")]
    pub start_time_unix_ns: i64,
    #[prost(int64, tag = "7")]
    pub end_time_unix_ns: i64,
    /// Status
    #[prost(bool, tag = "8")]
    pub is_error: bool,
    /// "timeout", "panic", "user_error"
    #[prost(string, optional, tag = "9")]
    pub error_type: ::core::option::Option<::prost::alloc::string::String>,
    /// truncated to 1KB by server
    #[prost(string, optional, tag = "10")]
    pub error_message: ::core::option::Option<::prost::alloc::string::String>,
    /// Allowed attributes (server validates keys)
    #[prost(map = "string, string", tag = "11")]
    pub attributes:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportExecutionSpansRequest {
    /// SDK metadata
    #[prost(message, optional, tag = "1")]
    pub sdk_info: ::core::option::Option<SdkInfo>,
    /// Execution spans to report
    #[prost(message, repeated, tag = "2")]
    pub spans: ::prost::alloc::vec::Vec<ExecutionSpan>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReportExecutionSpansResponse {
    /// Number of spans accepted
    #[prost(int32, tag = "1")]
    pub accepted_count: i32,
    /// Number of spans rejected (invalid type, wrong tenant, etc.)
    #[prost(int32, tag = "2")]
    pub rejected_count: i32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerRegistrationRequest {
    /// Worker identity
    #[prost(string, tag = "1")]
    pub worker_name: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub worker_version: ::prost::alloc::string::String,
    /// "WORKFLOW", "TASK", "UNIFIED"
    #[prost(string, tag = "3")]
    pub worker_type: ::prost::alloc::string::String,
    /// Organization and team
    #[prost(string, tag = "4")]
    pub org_id: ::prost::alloc::string::String,
    /// NULL = org-level (shared infrastructure)
    #[prost(string, optional, tag = "5")]
    pub team_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Connection info
    #[prost(string, tag = "6")]
    pub host_name: ::prost::alloc::string::String,
    #[prost(string, tag = "7")]
    pub process_id: ::prost::alloc::string::String,
    /// Capabilities
    #[prost(message, repeated, tag = "8")]
    pub workflows: ::prost::alloc::vec::Vec<WorkflowCapability>,
    #[prost(message, repeated, tag = "9")]
    pub tasks: ::prost::alloc::vec::Vec<TaskCapability>,
    /// Metadata
    #[prost(bytes = "vec", tag = "10")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowCapability {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "4")]
    pub timeout_seconds: ::core::option::Option<i32>,
    #[prost(bool, tag = "5")]
    pub cancellable: bool,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "7")]
    pub retry_policy: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
    /// Code-first workflow versioning (added in workflow-versioning-implementation)
    ///
    /// Semantic version (e.g., "1.0.0", "1.2.3")
    #[prost(string, tag = "9")]
    pub version: ::prost::alloc::string::String,
    /// SHA-256 hash of workflow bytecode
    #[prost(string, tag = "10")]
    pub content_hash: ::prost::alloc::string::String,
    /// Input/output schema (JSON Schema format, same as TaskCapability)
    #[prost(bytes = "vec", tag = "11")]
    pub input_schema: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "12")]
    pub output_schema: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskCapability {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub description: ::prost::alloc::string::String,
    #[prost(int32, optional, tag = "4")]
    pub timeout_seconds: ::core::option::Option<i32>,
    #[prost(bool, tag = "5")]
    pub cancellable: bool,
    #[prost(string, repeated, tag = "6")]
    pub tags: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "7")]
    pub retry_policy: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "8")]
    pub input_schema: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "9")]
    pub output_schema: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "10")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerRegistrationResponse {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(bool, tag = "2")]
    pub success: bool,
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
    #[prost(message, repeated, tag = "4")]
    pub workflow_conflicts: ::prost::alloc::vec::Vec<WorkflowConflict>,
    #[prost(message, repeated, tag = "5")]
    pub task_conflicts: ::prost::alloc::vec::Vec<TaskConflict>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkflowConflict {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub existing_worker_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TaskConflict {
    #[prost(string, tag = "1")]
    pub kind: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub existing_worker_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkerHeartbeatRequest {
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub workflow_kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "3")]
    pub task_kinds: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "4")]
    pub health_info: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum StreamEventType {
    Unspecified = 0,
    /// SDK-originated events (for real-time data streaming via gRPC)
    /// Note: Server-originated task state events (task_created, task_started, etc.)
    /// are published directly to SSE and don't use this proto enum.
    Token = 1,
    Progress = 2,
    Data = 3,
    Error = 4,
}
impl StreamEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            StreamEventType::Unspecified => "STREAM_EVENT_TYPE_UNSPECIFIED",
            StreamEventType::Token => "TOKEN",
            StreamEventType::Progress => "PROGRESS",
            StreamEventType::Data => "DATA",
            StreamEventType::Error => "ERROR",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "STREAM_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "TOKEN" => Some(Self::Token),
            "PROGRESS" => Some(Self::Progress),
            "DATA" => Some(Self::Data),
            "ERROR" => Some(Self::Error),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum CommandType {
    Unspecified = 0,
    RecordOperation = 1,
    SetState = 2,
    ClearState = 3,
    ScheduleTask = 4,
    CompleteWorkflow = 5,
    FailWorkflow = 6,
    SuspendWorkflow = 7,
    CancelWorkflow = 8,
    CreatePromise = 9,
    ResolvePromise = 10,
    ScheduleChildWorkflow = 11,
    StartTimer = 12,
    CancelTimer = 13,
    RequestCancelChildWorkflow = 14,
}
impl CommandType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            CommandType::Unspecified => "COMMAND_TYPE_UNSPECIFIED",
            CommandType::RecordOperation => "RECORD_OPERATION",
            CommandType::SetState => "SET_STATE",
            CommandType::ClearState => "CLEAR_STATE",
            CommandType::ScheduleTask => "SCHEDULE_TASK",
            CommandType::CompleteWorkflow => "COMPLETE_WORKFLOW",
            CommandType::FailWorkflow => "FAIL_WORKFLOW",
            CommandType::SuspendWorkflow => "SUSPEND_WORKFLOW",
            CommandType::CancelWorkflow => "CANCEL_WORKFLOW",
            CommandType::CreatePromise => "CREATE_PROMISE",
            CommandType::ResolvePromise => "RESOLVE_PROMISE",
            CommandType::ScheduleChildWorkflow => "SCHEDULE_CHILD_WORKFLOW",
            CommandType::StartTimer => "START_TIMER",
            CommandType::CancelTimer => "CANCEL_TIMER",
            CommandType::RequestCancelChildWorkflow => "REQUEST_CANCEL_CHILD_WORKFLOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "COMMAND_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "RECORD_OPERATION" => Some(Self::RecordOperation),
            "SET_STATE" => Some(Self::SetState),
            "CLEAR_STATE" => Some(Self::ClearState),
            "SCHEDULE_TASK" => Some(Self::ScheduleTask),
            "COMPLETE_WORKFLOW" => Some(Self::CompleteWorkflow),
            "FAIL_WORKFLOW" => Some(Self::FailWorkflow),
            "SUSPEND_WORKFLOW" => Some(Self::SuspendWorkflow),
            "CANCEL_WORKFLOW" => Some(Self::CancelWorkflow),
            "CREATE_PROMISE" => Some(Self::CreatePromise),
            "RESOLVE_PROMISE" => Some(Self::ResolvePromise),
            "SCHEDULE_CHILD_WORKFLOW" => Some(Self::ScheduleChildWorkflow),
            "START_TIMER" => Some(Self::StartTimer),
            "CANCEL_TIMER" => Some(Self::CancelTimer),
            "REQUEST_CANCEL_CHILD_WORKFLOW" => Some(Self::RequestCancelChildWorkflow),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum WorkflowStatus {
    Unspecified = 0,
    Running = 1,
    Suspended = 2,
    Completed = 3,
    Cancelled = 4,
    Failed = 5,
}
impl WorkflowStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            WorkflowStatus::Unspecified => "WORKFLOW_STATUS_UNSPECIFIED",
            WorkflowStatus::Running => "RUNNING",
            WorkflowStatus::Suspended => "SUSPENDED",
            WorkflowStatus::Completed => "COMPLETED",
            WorkflowStatus::Cancelled => "CANCELLED",
            WorkflowStatus::Failed => "FAILED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "WORKFLOW_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "RUNNING" => Some(Self::Running),
            "SUSPENDED" => Some(Self::Suspended),
            "COMPLETED" => Some(Self::Completed),
            "CANCELLED" => Some(Self::Cancelled),
            "FAILED" => Some(Self::Failed),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod workflow_dispatch_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkflowDispatchClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkflowDispatchClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkflowDispatchClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowDispatchClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            WorkflowDispatchClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Poll for workflows (unary RPC with long polling)
        /// Worker calls this repeatedly to receive work
        pub async fn poll_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::PollRequest>,
        ) -> std::result::Result<tonic::Response<super::PollResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/PollWorkflow");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "PollWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Subscribe to work-available notifications (server-to-client stream)
        /// Worker maintains this stream to receive instant notifications
        pub async fn subscribe_to_notifications(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscriptionRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::WorkAvailableEvent>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/SubscribeToNotifications",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "SubscribeToNotifications",
            ));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Start workflow programmatically
        pub async fn start_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::StartWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::StartWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/StartWorkflow");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "StartWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get visual workflow definition by ID (for lazy loading)
        pub async fn get_visual_workflow_definition_by_id(
            &mut self,
            request: impl tonic::IntoRequest<super::GetVisualWorkflowDefinitionByIdRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetVisualWorkflowDefinitionByIdResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/GetVisualWorkflowDefinitionById",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "GetVisualWorkflowDefinitionById",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Start a child workflow
        pub async fn start_child_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::StartChildWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::StartChildWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/StartChildWorkflow",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "StartChildWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Resolve a durable promise
        pub async fn resolve_promise(
            &mut self,
            request: impl tonic::IntoRequest<super::ResolvePromiseRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/ResolvePromise");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "ResolvePromise",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Reject a durable promise
        pub async fn reject_promise(
            &mut self,
            request: impl tonic::IntoRequest<super::RejectPromiseRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/RejectPromise");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "RejectPromise",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Atomically start a workflow (if not exists) and send a signal
        pub async fn signal_with_start_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalWithStartWorkflowRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SignalWithStartWorkflowResponse>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/SignalWithStartWorkflow",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "SignalWithStartWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Send a signal to an existing workflow
        pub async fn signal_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::SignalWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/SignalWorkflow");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "SignalWorkflow",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Get workflow events (for replay)
        pub async fn get_events(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEventsRequest>,
        ) -> std::result::Result<tonic::Response<super::GetEventsResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowDispatch/GetEvents");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.WorkflowDispatch", "GetEvents"));
            self.inner.unary(req, path, codec).await
        }
        /// Submit workflow commands after execution
        pub async fn submit_workflow_commands(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitWorkflowCommandsRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/SubmitWorkflowCommands",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "SubmitWorkflowCommands",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Report SDK execution spans for unified tracing
        pub async fn report_execution_spans(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportExecutionSpansRequest>,
        ) -> std::result::Result<tonic::Response<super::ReportExecutionSpansResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.WorkflowDispatch/ReportExecutionSpans",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkflowDispatch",
                "ReportExecutionSpans",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod workflow_query_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkflowQueryClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkflowQueryClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkflowQueryClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkflowQueryClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            WorkflowQueryClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Query workflow state
        pub async fn query_workflow(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryWorkflowRequest>,
        ) -> std::result::Result<tonic::Response<super::QueryWorkflowResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkflowQuery/QueryWorkflow");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.WorkflowQuery", "QueryWorkflow"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod task_execution_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct TaskExecutionClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TaskExecutionClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TaskExecutionClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaskExecutionClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            TaskExecutionClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Submit a task for execution
        pub async fn submit_task(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitTaskResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/SubmitTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "SubmitTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Poll for tasks to execute (long polling)
        pub async fn poll_task(
            &mut self,
            request: impl tonic::IntoRequest<super::PollTaskRequest>,
        ) -> std::result::Result<tonic::Response<super::PollTaskResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/PollTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "PollTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Complete a task
        pub async fn complete_task(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteTaskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/CompleteTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "CompleteTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Fail a task
        pub async fn fail_task(
            &mut self,
            request: impl tonic::IntoRequest<super::FailTaskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/FailTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "FailTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Report task progress
        pub async fn report_progress(
            &mut self,
            request: impl tonic::IntoRequest<super::ReportProgressRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/ReportProgress");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "ReportProgress"));
            self.inner.unary(req, path, codec).await
        }
        /// Send heartbeat
        pub async fn heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::HeartbeatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/Heartbeat");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "Heartbeat"));
            self.inner.unary(req, path, codec).await
        }
        /// Cancel a task
        pub async fn cancel_task(
            &mut self,
            request: impl tonic::IntoRequest<super::CancelTaskRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/CancelTask");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "CancelTask"));
            self.inner.unary(req, path, codec).await
        }
        /// Log a message
        pub async fn log_message(
            &mut self,
            request: impl tonic::IntoRequest<super::LogMessageRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/LogMessage");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "LogMessage"));
            self.inner.unary(req, path, codec).await
        }
        /// Get task state value
        pub async fn get_state(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStateRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStateResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/GetState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "GetState"));
            self.inner.unary(req, path, codec).await
        }
        /// Set task state value
        pub async fn set_state(
            &mut self,
            request: impl tonic::IntoRequest<super::SetStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/SetState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "SetState"));
            self.inner.unary(req, path, codec).await
        }
        /// Clear task state value
        pub async fn clear_state(
            &mut self,
            request: impl tonic::IntoRequest<super::ClearStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/ClearState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "ClearState"));
            self.inner.unary(req, path, codec).await
        }
        /// Clear all task state
        pub async fn clear_all_state(
            &mut self,
            request: impl tonic::IntoRequest<super::ClearAllStateRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/ClearAllState");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "ClearAllState"));
            self.inner.unary(req, path, codec).await
        }
        /// Get all state keys
        pub async fn get_state_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::GetStateKeysRequest>,
        ) -> std::result::Result<tonic::Response<super::GetStateKeysResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/GetStateKeys");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "GetStateKeys"));
            self.inner.unary(req, path, codec).await
        }
        /// Stream task data (tokens, progress, etc.)
        pub async fn stream_task_data(
            &mut self,
            request: impl tonic::IntoRequest<super::StreamTaskDataRequest>,
        ) -> std::result::Result<tonic::Response<super::StreamTaskDataResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.TaskExecution/StreamTaskData");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.TaskExecution", "StreamTaskData"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod worker_lifecycle_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct WorkerLifecycleClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl WorkerLifecycleClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> WorkerLifecycleClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> WorkerLifecycleClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            WorkerLifecycleClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Register worker with workflows and tasks
        pub async fn register_worker(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkerRegistrationRequest>,
        ) -> std::result::Result<tonic::Response<super::WorkerRegistrationResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkerLifecycle/RegisterWorker");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkerLifecycle",
                "RegisterWorker",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Send heartbeat to update worker status
        pub async fn send_heartbeat(
            &mut self,
            request: impl tonic::IntoRequest<super::WorkerHeartbeatRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.WorkerLifecycle/SendHeartbeat");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.WorkerLifecycle",
                "SendHeartbeat",
            ));
            self.inner.unary(req, path, codec).await
        }
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollAgentRequest {
    /// Unique identifier for this worker
    #[prost(string, tag = "1")]
    pub worker_id: ::prost::alloc::string::String,
    /// Organization ID to poll agents from
    #[prost(string, tag = "2")]
    pub org_id: ::prost::alloc::string::String,
    /// Queue to poll from (e.g., "default", "gpu-workers")
    #[prost(string, tag = "3")]
    pub queue: ::prost::alloc::string::String,
    /// Long polling timeout in seconds (e.g., 60)
    #[prost(int64, tag = "4")]
    pub timeout_seconds: i64,
    /// Agent kinds this worker can handle (empty = all kinds)
    #[prost(string, repeated, tag = "5")]
    pub agent_capabilities: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Worker pool ID for tenant isolation (empty = any pool)
    #[prost(string, optional, tag = "6")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PollAgentResponse {
    /// Agent execution info (null if no work available)
    #[prost(message, optional, tag = "1")]
    pub agent_execution: ::core::option::Option<AgentExecutionInfo>,
    /// W3C Trace Context traceparent for distributed tracing
    #[prost(string, tag = "2")]
    pub traceparent: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentExecutionInfo {
    /// Unique agent execution ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Agent kind/type
    #[prost(string, tag = "2")]
    pub kind: ::prost::alloc::string::String,
    /// Organization ID
    #[prost(string, tag = "3")]
    pub org_id: ::prost::alloc::string::String,
    /// Input data (serialized bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub input: ::prost::alloc::vec::Vec<u8>,
    /// Queue for worker routing
    #[prost(string, tag = "5")]
    pub queue: ::prost::alloc::string::String,
    /// Creation timestamp (milliseconds since epoch)
    #[prost(int64, tag = "6")]
    pub created_at_ms: i64,
    /// Current checkpoint sequence (-1 if no checkpoint yet)
    #[prost(int32, tag = "7")]
    pub current_checkpoint_seq: i32,
    /// Persistence mode: "REMOTE" or "LOCAL"
    #[prost(string, tag = "8")]
    pub persistence_mode: ::prost::alloc::string::String,
    /// Agent definition ID (if created from a definition)
    #[prost(string, optional, tag = "9")]
    pub agent_definition_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Worker pool ID (denormalized for dispatch)
    #[prost(string, optional, tag = "10")]
    pub worker_pool_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Arbitrary metadata (JSON)
    #[prost(bytes = "vec", tag = "11")]
    pub metadata: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetEntriesRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Load entries after this entry ID (for incremental loads)
    /// If empty, loads all entries
    #[prost(string, optional, tag = "2")]
    pub after_entry_id: ::core::option::Option<::prost::alloc::string::String>,
}
/// Server-side streaming response - one entry per message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentEntryChunk {
    #[prost(message, optional, tag = "1")]
    pub entry: ::core::option::Option<AgentEntry>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentEntry {
    /// Entry ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Parent entry ID (null for root entries)
    #[prost(string, optional, tag = "2")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Entry type: "message", "llm_call", "injection"
    #[prost(string, tag = "3")]
    pub entry_type: ::prost::alloc::string::String,
    /// Role (for message type): "system", "user", "assistant", "tool_result"
    #[prost(string, optional, tag = "4")]
    pub role: ::core::option::Option<::prost::alloc::string::String>,
    /// Content (serialized, format depends on type)
    #[prost(bytes = "vec", tag = "5")]
    pub content: ::prost::alloc::vec::Vec<u8>,
    /// Turn ID for grouping related entries
    #[prost(string, optional, tag = "6")]
    pub turn_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Token usage (for llm_call entries)
    #[prost(message, optional, tag = "7")]
    pub token_usage: ::core::option::Option<TokenUsage>,
    /// Creation timestamp (milliseconds since epoch)
    #[prost(int64, tag = "8")]
    pub created_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TokenUsage {
    #[prost(int64, tag = "1")]
    pub input_tokens: i64,
    #[prost(int64, tag = "2")]
    pub output_tokens: i64,
    #[prost(int64, optional, tag = "3")]
    pub cache_read_tokens: ::core::option::Option<i64>,
    #[prost(int64, optional, tag = "4")]
    pub cache_write_tokens: ::core::option::Option<i64>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEntryRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Parent entry ID (null for root entries)
    #[prost(string, optional, tag = "2")]
    pub parent_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Entry type: "message", "llm_call", "injection"
    #[prost(string, tag = "3")]
    pub entry_type: ::prost::alloc::string::String,
    /// Role (for message type): "system", "user", "assistant", "tool_result"
    #[prost(string, optional, tag = "4")]
    pub role: ::core::option::Option<::prost::alloc::string::String>,
    /// Content (serialized)
    #[prost(bytes = "vec", tag = "5")]
    pub content: ::prost::alloc::vec::Vec<u8>,
    /// Turn ID for grouping related entries
    #[prost(string, optional, tag = "6")]
    pub turn_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Token usage (for llm_call entries)
    #[prost(message, optional, tag = "7")]
    pub token_usage: ::core::option::Option<TokenUsage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AppendEntryResponse {
    /// Created entry ID
    #[prost(string, tag = "1")]
    pub entry_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetCheckpointResponse {
    /// Latest checkpoint (null if no checkpoint yet)
    #[prost(message, optional, tag = "1")]
    pub checkpoint: ::core::option::Option<AgentCheckpoint>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentCheckpoint {
    /// Checkpoint ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Sequence number (1, 2, 3, ...)
    #[prost(int32, tag = "2")]
    pub sequence: i32,
    /// Leaf entry ID at checkpoint time
    #[prost(string, optional, tag = "3")]
    pub leaf_entry_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Serialized state (JSON)
    #[prost(bytes = "vec", tag = "4")]
    pub state: ::prost::alloc::vec::Vec<u8>,
    /// Creation timestamp (milliseconds since epoch)
    #[prost(int64, tag = "5")]
    pub created_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCheckpointRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Leaf entry ID at checkpoint time
    #[prost(string, optional, tag = "2")]
    pub leaf_entry_id: ::core::option::Option<::prost::alloc::string::String>,
    /// Serialized state (JSON)
    #[prost(bytes = "vec", tag = "3")]
    pub state: ::prost::alloc::vec::Vec<u8>,
    /// Token usage snapshot for this checkpoint
    #[prost(message, optional, tag = "4")]
    pub cumulative_token_usage: ::core::option::Option<TokenUsage>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubmitCheckpointResponse {
    /// Created checkpoint ID
    #[prost(string, tag = "1")]
    pub checkpoint_id: ::prost::alloc::string::String,
    /// Assigned sequence number
    #[prost(int32, tag = "2")]
    pub sequence: i32,
}
/// First message in stream: task header with metadata
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleAgentTaskHeader {
    /// Agent execution ID (parent)
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Task kind
    #[prost(string, tag = "2")]
    pub task_kind: ::prost::alloc::string::String,
    /// Queue for task routing (default: inherit from agent)
    #[prost(string, optional, tag = "3")]
    pub queue: ::core::option::Option<::prost::alloc::string::String>,
    /// Max retries (default: 3)
    #[prost(int32, optional, tag = "4")]
    pub max_retries: ::core::option::Option<i32>,
    /// Timeout in milliseconds
    #[prost(int64, optional, tag = "5")]
    pub timeout_ms: ::core::option::Option<i64>,
    /// Idempotency key for preventing duplicate tasks
    /// Format: {agent_execution_id}:{checkpoint_seq}:{task_index}
    #[prost(string, optional, tag = "6")]
    pub idempotency_key: ::core::option::Option<::prost::alloc::string::String>,
    /// TTL for idempotency key in seconds (default: 86400)
    #[prost(int64, optional, tag = "7")]
    pub idempotency_key_ttl_seconds: ::core::option::Option<i64>,
    /// Arbitrary metadata
    #[prost(map = "string, string", tag = "8")]
    pub metadata:
        ::std::collections::HashMap<::prost::alloc::string::String, ::prost::alloc::string::String>,
}
/// Client-side streaming message
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleAgentTaskChunk {
    #[prost(oneof = "schedule_agent_task_chunk::Chunk", tags = "1, 2")]
    pub chunk: ::core::option::Option<schedule_agent_task_chunk::Chunk>,
}
/// Nested message and enum types in `ScheduleAgentTaskChunk`.
pub mod schedule_agent_task_chunk {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Chunk {
        /// First message: task metadata
        #[prost(message, tag = "1")]
        Header(super::ScheduleAgentTaskHeader),
        /// Subsequent messages: input data chunks (~64KB each)
        #[prost(bytes, tag = "2")]
        InputChunk(::prost::alloc::vec::Vec<u8>),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScheduleAgentTaskResponse {
    /// Created task execution ID
    #[prost(string, tag = "1")]
    pub task_execution_id: ::prost::alloc::string::String,
    /// Whether idempotency key was used
    #[prost(bool, tag = "2")]
    pub idempotency_key_used: bool,
    /// Whether a new task was created (false if existing returned)
    #[prost(bool, tag = "3")]
    pub idempotency_key_new: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CompleteAgentRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Output data (serialized)
    #[prost(bytes = "vec", tag = "2")]
    pub output: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FailAgentRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Error message
    #[prost(string, tag = "2")]
    pub error: ::prost::alloc::string::String,
    /// Stack trace (optional)
    #[prost(string, optional, tag = "3")]
    pub stack_trace: ::core::option::Option<::prost::alloc::string::String>,
    /// Failure type: "CODE_BUG", "TRANSIENT_ERROR", "BUSINESS_LOGIC", etc.
    #[prost(string, optional, tag = "4")]
    pub failure_type: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SuspendAgentRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Optional reason for suspension
    #[prost(string, optional, tag = "3")]
    pub reason: ::core::option::Option<::prost::alloc::string::String>,
    /// Wait condition - exactly one must be set
    #[prost(oneof = "suspend_agent_request::WaitCondition", tags = "2, 4")]
    pub wait_condition: ::core::option::Option<suspend_agent_request::WaitCondition>,
}
/// Nested message and enum types in `SuspendAgentRequest`.
pub mod suspend_agent_request {
    /// Wait condition - exactly one must be set
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum WaitCondition {
        /// Wait for external signal (e.g., "userMessage")
        #[prost(string, tag = "2")]
        WaitForSignal(::prost::alloc::string::String),
        /// Wait for task completion (task execution ID)
        #[prost(string, tag = "4")]
        WaitForTask(::prost::alloc::string::String),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalAgentRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Signal name (e.g., "userMessage", "cancel")
    #[prost(string, tag = "2")]
    pub signal_name: ::prost::alloc::string::String,
    /// Signal value (serialized, optional)
    #[prost(bytes = "vec", tag = "3")]
    pub signal_value: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SignalAgentResponse {
    /// Created signal ID
    #[prost(string, tag = "1")]
    pub signal_id: ::prost::alloc::string::String,
    /// Whether agent transitioned from WAITING to PENDING
    #[prost(bool, tag = "2")]
    pub agent_resumed: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumeSignalsRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Signal name to consume (empty = all signals)
    #[prost(string, optional, tag = "2")]
    pub signal_name: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ConsumeSignalsResponse {
    /// Consumed signals
    #[prost(message, repeated, tag = "1")]
    pub signals: ::prost::alloc::vec::Vec<AgentSignal>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AgentSignal {
    /// Signal ID
    #[prost(string, tag = "1")]
    pub id: ::prost::alloc::string::String,
    /// Signal name
    #[prost(string, tag = "2")]
    pub signal_name: ::prost::alloc::string::String,
    /// Signal value (serialized, optional)
    #[prost(bytes = "vec", tag = "3")]
    pub signal_value: ::prost::alloc::vec::Vec<u8>,
    /// Creation timestamp (milliseconds since epoch)
    #[prost(int64, tag = "4")]
    pub created_at_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HasSignalRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Signal name to check
    #[prost(string, tag = "2")]
    pub signal_name: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct HasSignalResponse {
    /// Whether unconsumed signal exists
    #[prost(bool, tag = "1")]
    pub has_signal: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentTaskResultRequest {
    /// Agent execution ID (for authorization)
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Task execution ID to query
    #[prost(string, tag = "2")]
    pub task_execution_id: ::prost::alloc::string::String,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAgentTaskResultResponse {
    /// Task status: "PENDING", "RUNNING", "COMPLETED", "FAILED", "CANCELLED"
    #[prost(string, tag = "1")]
    pub status: ::prost::alloc::string::String,
    /// Output (if COMPLETED)
    #[prost(bytes = "vec", optional, tag = "2")]
    pub output: ::core::option::Option<::prost::alloc::vec::Vec<u8>>,
    /// Error message (if FAILED)
    #[prost(string, optional, tag = "3")]
    pub error: ::core::option::Option<::prost::alloc::string::String>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAgentDataRequest {
    /// Agent execution ID
    #[prost(string, tag = "1")]
    pub agent_execution_id: ::prost::alloc::string::String,
    /// Sequence number for ordering
    #[prost(int32, tag = "2")]
    pub sequence: i32,
    /// Event type
    #[prost(enumeration = "AgentStreamEventType", tag = "3")]
    pub event_type: i32,
    /// Event payload (JSON-encoded)
    #[prost(string, tag = "4")]
    pub payload: ::prost::alloc::string::String,
    /// Timestamp (milliseconds since epoch)
    #[prost(int64, tag = "5")]
    pub timestamp_ms: i64,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct StreamAgentDataResponse {
    /// Whether event was acknowledged
    #[prost(bool, tag = "1")]
    pub acknowledged: bool,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AgentStreamEventType {
    Unspecified = 0,
    /// Tokens from LLM response
    AgentToken = 1,
    /// Progress update
    AgentProgress = 2,
    /// Arbitrary data event
    AgentData = 3,
    /// Error event
    AgentError = 4,
    /// Tool invocation started
    AgentToolStart = 5,
    /// Tool invocation completed
    AgentToolEnd = 6,
}
impl AgentStreamEventType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            AgentStreamEventType::Unspecified => "AGENT_STREAM_EVENT_TYPE_UNSPECIFIED",
            AgentStreamEventType::AgentToken => "AGENT_TOKEN",
            AgentStreamEventType::AgentProgress => "AGENT_PROGRESS",
            AgentStreamEventType::AgentData => "AGENT_DATA",
            AgentStreamEventType::AgentError => "AGENT_ERROR",
            AgentStreamEventType::AgentToolStart => "AGENT_TOOL_START",
            AgentStreamEventType::AgentToolEnd => "AGENT_TOOL_END",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AGENT_STREAM_EVENT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "AGENT_TOKEN" => Some(Self::AgentToken),
            "AGENT_PROGRESS" => Some(Self::AgentProgress),
            "AGENT_DATA" => Some(Self::AgentData),
            "AGENT_ERROR" => Some(Self::AgentError),
            "AGENT_TOOL_START" => Some(Self::AgentToolStart),
            "AGENT_TOOL_END" => Some(Self::AgentToolEnd),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod agent_dispatch_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::http::Uri;
    use tonic::codegen::*;
    #[derive(Debug, Clone)]
    pub struct AgentDispatchClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl AgentDispatchClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> AgentDispatchClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> AgentDispatchClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<http::Request<tonic::body::BoxBody>>>::Error:
                Into<StdError> + Send + Sync,
        {
            AgentDispatchClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// Poll for available agent work (unary with long polling)
        /// Returns lightweight metadata - entries are loaded separately
        pub async fn poll_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::PollAgentRequest>,
        ) -> std::result::Result<tonic::Response<super::PollAgentResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/PollAgent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "PollAgent"));
            self.inner.unary(req, path, codec).await
        }
        /// Load conversation entries (SERVER-SIDE STREAMING)
        /// Streams entries one by one to handle large conversations (4MB gRPC limit)
        pub async fn get_entries(
            &mut self,
            request: impl tonic::IntoRequest<super::GetEntriesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::AgentEntryChunk>>,
            tonic::Status,
        > {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/GetEntries");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "GetEntries"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// Persist a single conversation entry (unary)
        pub async fn append_entry(
            &mut self,
            request: impl tonic::IntoRequest<super::AppendEntryRequest>,
        ) -> std::result::Result<tonic::Response<super::AppendEntryResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/AppendEntry");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "AppendEntry"));
            self.inner.unary(req, path, codec).await
        }
        /// Checkpoint management (unary)
        pub async fn get_latest_checkpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::GetCheckpointRequest>,
        ) -> std::result::Result<tonic::Response<super::GetCheckpointResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/flovyn.v1.AgentDispatch/GetLatestCheckpoint",
            );
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.AgentDispatch",
                "GetLatestCheckpoint",
            ));
            self.inner.unary(req, path, codec).await
        }
        pub async fn submit_checkpoint(
            &mut self,
            request: impl tonic::IntoRequest<super::SubmitCheckpointRequest>,
        ) -> std::result::Result<tonic::Response<super::SubmitCheckpointResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/SubmitCheckpoint");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.AgentDispatch",
                "SubmitCheckpoint",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Task scheduling (CLIENT-SIDE STREAMING for large inputs)
        /// First chunk: header with task kind, options
        /// Subsequent chunks: serialized input data (~64KB each)
        pub async fn schedule_agent_task(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ScheduleAgentTaskChunk>,
        ) -> std::result::Result<tonic::Response<super::ScheduleAgentTaskResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/ScheduleAgentTask");
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.AgentDispatch",
                "ScheduleAgentTask",
            ));
            self.inner.client_streaming(req, path, codec).await
        }
        /// Agent completion (unary)
        pub async fn complete_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::CompleteAgentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/CompleteAgent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "CompleteAgent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn fail_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::FailAgentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/FailAgent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "FailAgent"));
            self.inner.unary(req, path, codec).await
        }
        /// Suspension for multi-turn interaction (unary)
        pub async fn suspend_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::SuspendAgentRequest>,
        ) -> std::result::Result<tonic::Response<()>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/SuspendAgent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "SuspendAgent"));
            self.inner.unary(req, path, codec).await
        }
        /// Signal management (unary)
        pub async fn signal_agent(
            &mut self,
            request: impl tonic::IntoRequest<super::SignalAgentRequest>,
        ) -> std::result::Result<tonic::Response<super::SignalAgentResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/SignalAgent");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "SignalAgent"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn consume_signals(
            &mut self,
            request: impl tonic::IntoRequest<super::ConsumeSignalsRequest>,
        ) -> std::result::Result<tonic::Response<super::ConsumeSignalsResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/ConsumeSignals");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "ConsumeSignals"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn has_signal(
            &mut self,
            request: impl tonic::IntoRequest<super::HasSignalRequest>,
        ) -> std::result::Result<tonic::Response<super::HasSignalResponse>, tonic::Status> {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/HasSignal");
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("flovyn.v1.AgentDispatch", "HasSignal"));
            self.inner.unary(req, path, codec).await
        }
        /// Query task execution result
        pub async fn get_agent_task_result(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAgentTaskResultRequest>,
        ) -> std::result::Result<tonic::Response<super::GetAgentTaskResultResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/GetAgentTaskResult");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.AgentDispatch",
                "GetAgentTaskResult",
            ));
            self.inner.unary(req, path, codec).await
        }
        /// Real-time data streaming (CLIENT-SIDE STREAMING)
        /// Used for streaming tokens, tool outputs, events to SSE subscribers
        pub async fn stream_agent_data(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::StreamAgentDataRequest>,
        ) -> std::result::Result<tonic::Response<super::StreamAgentDataResponse>, tonic::Status>
        {
            self.inner.ready().await.map_err(|e| {
                tonic::Status::new(
                    tonic::Code::Unknown,
                    format!("Service was not ready: {}", e.into()),
                )
            })?;
            let codec = tonic::codec::ProstCodec::default();
            let path =
                http::uri::PathAndQuery::from_static("/flovyn.v1.AgentDispatch/StreamAgentData");
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new(
                "flovyn.v1.AgentDispatch",
                "StreamAgentData",
            ));
            self.inner.client_streaming(req, path, codec).await
        }
    }
}
