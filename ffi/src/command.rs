//! FFI workflow command types.
//!
//! These commands are generated by the language SDK during workflow execution
//! and sent back to the core for processing.

use uuid::Uuid;

/// Workflow commands that can be generated during execution.
///
/// The language SDK processes workflow activations and generates these commands
/// to be sent back to the core.
#[derive(Debug, Clone, uniffi::Enum)]
pub enum FfiWorkflowCommand {
    /// Record the result of a deterministic operation.
    RecordOperation {
        /// Unique operation name for replay matching.
        operation_name: String,
        /// Serialized result as JSON bytes.
        result: Vec<u8>,
    },

    /// Set workflow state.
    SetState {
        /// State key.
        key: String,
        /// Serialized value as JSON bytes.
        value: Vec<u8>,
    },

    /// Clear a workflow state key.
    ClearState {
        /// State key to clear.
        key: String,
    },

    /// Schedule a task for execution.
    ScheduleTask {
        /// Unique task execution ID.
        task_execution_id: String,
        /// Task type/kind.
        task_type: String,
        /// Serialized input as JSON bytes.
        input: Vec<u8>,
        /// Optional priority in seconds.
        priority_seconds: Option<i32>,
        /// Optional max retries.
        max_retries: Option<u32>,
        /// Optional timeout in milliseconds.
        timeout_ms: Option<i64>,
        /// Optional queue name.
        queue: Option<String>,
    },

    /// Schedule a child workflow.
    ScheduleChildWorkflow {
        /// Child workflow name.
        name: String,
        /// Optional workflow kind.
        kind: Option<String>,
        /// Child execution ID.
        child_execution_id: String,
        /// Serialized input as JSON bytes.
        input: Vec<u8>,
        /// Task queue for the child.
        task_queue: String,
        /// Priority in seconds.
        priority_seconds: i32,
    },

    /// Complete the workflow successfully.
    CompleteWorkflow {
        /// Serialized output as JSON bytes.
        output: Vec<u8>,
    },

    /// Fail the workflow with an error.
    FailWorkflow {
        /// Error message.
        error: String,
        /// Stack trace (optional).
        stack_trace: String,
        /// Failure type (optional).
        failure_type: Option<String>,
    },

    /// Suspend the workflow.
    SuspendWorkflow {
        /// Reason for suspension.
        reason: String,
    },

    /// Cancel the workflow.
    CancelWorkflow {
        /// Reason for cancellation.
        reason: String,
    },

    /// Create a durable promise.
    CreatePromise {
        /// Promise ID.
        promise_id: String,
        /// Optional timeout in milliseconds.
        timeout_ms: Option<i64>,
    },

    /// Resolve a durable promise.
    ResolvePromise {
        /// Promise ID.
        promise_id: String,
        /// Serialized value as JSON bytes.
        value: Vec<u8>,
    },

    /// Start a timer.
    StartTimer {
        /// Timer ID.
        timer_id: String,
        /// Duration in milliseconds.
        duration_ms: i64,
    },

    /// Cancel a timer.
    CancelTimer {
        /// Timer ID to cancel.
        timer_id: String,
    },

    /// Request cancellation of a task.
    RequestCancelTask {
        /// Task execution ID to cancel.
        task_execution_id: String,
    },

    /// Request cancellation of a child workflow.
    RequestCancelChildWorkflow {
        /// Child execution ID to cancel.
        child_execution_id: String,
    },
}

impl FfiWorkflowCommand {
    /// Convert to core WorkflowCommand with a sequence number.
    pub fn to_core_command(&self, sequence_number: i32) -> flovyn_core::WorkflowCommand {
        use flovyn_core::WorkflowCommand;

        match self {
            FfiWorkflowCommand::RecordOperation {
                operation_name,
                result,
            } => WorkflowCommand::RecordOperation {
                sequence_number,
                operation_name: operation_name.clone(),
                result: serde_json::from_slice(result).unwrap_or(serde_json::Value::Null),
            },
            FfiWorkflowCommand::SetState { key, value } => WorkflowCommand::SetState {
                sequence_number,
                key: key.clone(),
                value: serde_json::from_slice(value).unwrap_or(serde_json::Value::Null),
            },
            FfiWorkflowCommand::ClearState { key } => WorkflowCommand::ClearState {
                sequence_number,
                key: key.clone(),
            },
            FfiWorkflowCommand::ScheduleTask {
                task_execution_id,
                task_type,
                input,
                priority_seconds,
                max_retries,
                timeout_ms,
                queue,
            } => WorkflowCommand::ScheduleTask {
                sequence_number,
                task_type: task_type.clone(),
                task_execution_id: Uuid::parse_str(task_execution_id)
                    .unwrap_or_else(|_| Uuid::nil()),
                input: serde_json::from_slice(input).unwrap_or(serde_json::Value::Null),
                priority_seconds: *priority_seconds,
                max_retries: *max_retries,
                timeout_ms: *timeout_ms,
                queue: queue.clone(),
            },
            FfiWorkflowCommand::ScheduleChildWorkflow {
                name,
                kind,
                child_execution_id,
                input,
                task_queue,
                priority_seconds,
            } => WorkflowCommand::ScheduleChildWorkflow {
                sequence_number,
                name: name.clone(),
                kind: kind.clone(),
                definition_id: None,
                child_execution_id: Uuid::parse_str(child_execution_id)
                    .unwrap_or_else(|_| Uuid::nil()),
                input: serde_json::from_slice(input).unwrap_or(serde_json::Value::Null),
                task_queue: task_queue.clone(),
                priority_seconds: *priority_seconds,
            },
            FfiWorkflowCommand::CompleteWorkflow { output } => WorkflowCommand::CompleteWorkflow {
                sequence_number,
                output: serde_json::from_slice(output).unwrap_or(serde_json::Value::Null),
            },
            FfiWorkflowCommand::FailWorkflow {
                error,
                stack_trace,
                failure_type,
            } => WorkflowCommand::FailWorkflow {
                sequence_number,
                error: error.clone(),
                stack_trace: stack_trace.clone(),
                failure_type: failure_type.clone(),
            },
            FfiWorkflowCommand::SuspendWorkflow { reason } => WorkflowCommand::SuspendWorkflow {
                sequence_number,
                reason: reason.clone(),
            },
            FfiWorkflowCommand::CancelWorkflow { reason } => WorkflowCommand::CancelWorkflow {
                sequence_number,
                reason: reason.clone(),
            },
            FfiWorkflowCommand::CreatePromise {
                promise_id,
                timeout_ms,
            } => WorkflowCommand::CreatePromise {
                sequence_number,
                promise_id: promise_id.clone(),
                timeout_ms: *timeout_ms,
            },
            FfiWorkflowCommand::ResolvePromise { promise_id, value } => {
                WorkflowCommand::ResolvePromise {
                    sequence_number,
                    promise_id: promise_id.clone(),
                    value: serde_json::from_slice(value).unwrap_or(serde_json::Value::Null),
                }
            }
            FfiWorkflowCommand::StartTimer {
                timer_id,
                duration_ms,
            } => WorkflowCommand::StartTimer {
                sequence_number,
                timer_id: timer_id.clone(),
                duration_ms: *duration_ms,
            },
            FfiWorkflowCommand::CancelTimer { timer_id } => WorkflowCommand::CancelTimer {
                sequence_number,
                timer_id: timer_id.clone(),
            },
            FfiWorkflowCommand::RequestCancelTask { task_execution_id } => {
                WorkflowCommand::RequestCancelTask {
                    sequence_number,
                    task_execution_id: Uuid::parse_str(task_execution_id)
                        .unwrap_or_else(|_| Uuid::nil()),
                }
            }
            FfiWorkflowCommand::RequestCancelChildWorkflow { child_execution_id } => {
                WorkflowCommand::RequestCancelChildWorkflow {
                    sequence_number,
                    child_execution_id: Uuid::parse_str(child_execution_id)
                        .unwrap_or_else(|_| Uuid::nil()),
                }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_record_operation_conversion() {
        let cmd = FfiWorkflowCommand::RecordOperation {
            operation_name: "test-op".to_string(),
            result: b"42".to_vec(),
        };
        let core_cmd = cmd.to_core_command(1);
        assert!(matches!(
            core_cmd,
            flovyn_core::WorkflowCommand::RecordOperation {
                sequence_number: 1,
                ..
            }
        ));
    }

    #[test]
    fn test_complete_workflow_conversion() {
        let cmd = FfiWorkflowCommand::CompleteWorkflow {
            output: b"{\"status\": \"ok\"}".to_vec(),
        };
        let core_cmd = cmd.to_core_command(10);
        assert!(matches!(
            core_cmd,
            flovyn_core::WorkflowCommand::CompleteWorkflow {
                sequence_number: 10,
                ..
            }
        ));
    }

    #[test]
    fn test_schedule_task_conversion() {
        let cmd = FfiWorkflowCommand::ScheduleTask {
            task_execution_id: Uuid::nil().to_string(),
            task_type: "my-task".to_string(),
            input: b"{}".to_vec(),
            priority_seconds: Some(30),
            max_retries: Some(3),
            timeout_ms: Some(60000),
            queue: Some("high-priority".to_string()),
        };
        let core_cmd = cmd.to_core_command(5);
        assert!(matches!(
            core_cmd,
            flovyn_core::WorkflowCommand::ScheduleTask {
                sequence_number: 5,
                ..
            }
        ));
    }
}
