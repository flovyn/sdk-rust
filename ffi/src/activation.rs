//! Activation types for the FFI protocol.
//!
//! These types define the activation-based protocol where:
//! - Core polls for work and returns activations
//! - Language SDK processes activations and returns completions
//! - Core handles gRPC communication, replay, and determinism validation

use crate::command::FfiWorkflowCommand;
use crate::types::FfiReplayEvent;

/// A workflow activation containing work for the language SDK to process.
///
/// Activations are returned by `CoreWorker::poll_workflow_activation()`.
#[derive(Debug, Clone, uniffi::Record)]
pub struct WorkflowActivation {
    /// The run ID for this workflow execution.
    pub run_id: String,

    /// The workflow execution ID.
    pub workflow_execution_id: String,

    /// The workflow kind/type.
    pub workflow_kind: String,

    /// Current timestamp in milliseconds since Unix epoch.
    pub timestamp_ms: i64,

    /// Whether we are currently replaying (re-executing from history).
    pub is_replaying: bool,

    /// Random seed for deterministic random number generation.
    pub random_seed: Vec<u8>,

    /// Jobs to process in this activation.
    pub jobs: Vec<WorkflowActivationJob>,

    /// Replay events from history (for determinism validation).
    pub history: Vec<FfiReplayEvent>,

    /// Current workflow state (key-value pairs as JSON bytes).
    pub state: Vec<StateEntry>,
}

/// A key-value pair for workflow state.
#[derive(Debug, Clone, uniffi::Record)]
pub struct StateEntry {
    /// State key.
    pub key: String,
    /// Serialized value as JSON bytes.
    pub value: Vec<u8>,
}

/// Jobs that can be included in a workflow activation.
#[derive(Debug, Clone, uniffi::Enum)]
pub enum WorkflowActivationJob {
    /// Initialize/start the workflow.
    Initialize {
        /// Serialized workflow input as JSON bytes.
        input: Vec<u8>,
    },

    /// A timer has fired.
    FireTimer {
        /// The timer ID that fired.
        timer_id: String,
    },

    /// A scheduled task has completed.
    ResolveTask {
        /// The task execution ID.
        task_execution_id: String,
        /// Serialized task result as JSON bytes.
        result: Vec<u8>,
    },

    /// A scheduled task has failed.
    FailTask {
        /// The task execution ID.
        task_execution_id: String,
        /// Error message.
        error: String,
        /// Whether this is retryable.
        retryable: bool,
    },

    /// A durable promise has been resolved.
    ResolvePromise {
        /// The promise name/ID.
        promise_name: String,
        /// Serialized promise value as JSON bytes.
        value: Vec<u8>,
    },

    /// A durable promise has been rejected.
    RejectPromise {
        /// The promise name/ID.
        promise_name: String,
        /// Error message.
        error: String,
    },

    /// A durable promise has timed out.
    TimeoutPromise {
        /// The promise name/ID.
        promise_name: String,
    },

    /// A child workflow has completed.
    ResolveChildWorkflow {
        /// The child workflow execution ID.
        child_execution_id: String,
        /// Serialized result as JSON bytes.
        result: Vec<u8>,
    },

    /// A child workflow has failed.
    FailChildWorkflow {
        /// The child workflow execution ID.
        child_execution_id: String,
        /// Error message.
        error: String,
    },

    /// A cancellation has been requested.
    CancelWorkflow,

    /// A signal was received (external event).
    Signal {
        /// Signal name.
        signal_name: String,
        /// Serialized signal payload as JSON bytes.
        payload: Vec<u8>,
    },

    /// Query the workflow state (read-only).
    Query {
        /// Query name.
        query_name: String,
        /// Serialized query args as JSON bytes.
        args: Vec<u8>,
    },
}

/// Completion sent back after processing a workflow activation.
#[derive(Debug, Clone, uniffi::Record)]
pub struct WorkflowActivationCompletion {
    /// The run ID this completion is for.
    pub run_id: String,

    /// Commands generated by the workflow execution.
    pub commands: Vec<FfiWorkflowCommand>,
}

/// A task activation containing work for the language SDK to process.
#[derive(Debug, Clone, uniffi::Record)]
pub struct TaskActivation {
    /// The task execution ID.
    pub task_execution_id: String,

    /// The task kind/type.
    pub task_kind: String,

    /// Serialized task input as JSON bytes.
    pub input: Vec<u8>,

    /// Workflow execution ID that scheduled this task (if any).
    pub workflow_execution_id: Option<String>,

    /// Current attempt number (1-based).
    pub attempt: u32,

    /// Maximum number of retries.
    pub max_retries: u32,

    /// Timeout in milliseconds (if set).
    pub timeout_ms: Option<i64>,
}

/// Completion sent back after processing a task activation.
#[derive(Debug, Clone, uniffi::Enum)]
pub enum TaskCompletion {
    /// Task completed successfully.
    Completed {
        /// The task execution ID.
        task_execution_id: String,
        /// Serialized output as JSON bytes.
        output: Vec<u8>,
    },

    /// Task failed.
    Failed {
        /// The task execution ID.
        task_execution_id: String,
        /// Error message.
        error: String,
        /// Whether this is retryable.
        retryable: bool,
    },

    /// Task was cancelled.
    Cancelled {
        /// The task execution ID.
        task_execution_id: String,
    },
}

impl TaskCompletion {
    /// Get the task execution ID from this completion.
    pub fn task_execution_id(&self) -> &str {
        match self {
            TaskCompletion::Completed {
                task_execution_id, ..
            } => task_execution_id,
            TaskCompletion::Failed {
                task_execution_id, ..
            } => task_execution_id,
            TaskCompletion::Cancelled { task_execution_id } => task_execution_id,
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_workflow_activation_creation() {
        let activation = WorkflowActivation {
            run_id: "run-123".to_string(),
            workflow_execution_id: "wf-456".to_string(),
            workflow_kind: "my-workflow".to_string(),
            timestamp_ms: 1234567890,
            is_replaying: false,
            random_seed: vec![1, 2, 3, 4],
            jobs: vec![WorkflowActivationJob::Initialize {
                input: b"{}".to_vec(),
            }],
            history: vec![],
            state: vec![],
        };
        assert_eq!(activation.run_id, "run-123");
        assert!(!activation.is_replaying);
    }

    #[test]
    fn test_task_completion_task_id() {
        let completion = TaskCompletion::Completed {
            task_execution_id: "task-123".to_string(),
            output: b"{}".to_vec(),
        };
        assert_eq!(completion.task_execution_id(), "task-123");

        let completion = TaskCompletion::Failed {
            task_execution_id: "task-456".to_string(),
            error: "test error".to_string(),
            retryable: true,
        };
        assert_eq!(completion.task_execution_id(), "task-456");
    }
}
